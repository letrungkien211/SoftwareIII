\documentclass[a4j,twoside]{jarticle}

\usepackage[dvipdfm]{graphicx}
\usepackage{array, amsmath, amssymb, ascmac, supertabular, moreverb, multicol}
\usepackage[dvipdfm]{hyperref}
%% \usepackage[dvipdfm]{xcolor}
% \hypersetup{urlbordercolor={1 1 1}}
% \hypersetup{bookmarksnumbered=true}
% \hypersetup{linkcolor={0 0 0}}
% \hypersetup{linkbordercolor={white white white}}
% \hypersetup{colorlinks=false}
\pagestyle{headings}

%講義・演習配布資料用設定集
\usepackage{enshu-lec}

\title{2009年度 機械情報夏学期\\計算機演習　ソケットプログラミング
}

\author{
担当：岡田 慧(k-okada@jsk.t.u-tokyo.ac.jp)\\
\url{http://www.jsk.t.u-tokyo.ac.jp/~k-okada/lecture/}\\
}

\date{2009年6月5日}
\setlength{\columnseprule}{0.5pt}
\setlength{\columnwidth}{.3\textwidth}
\setlength{\columnsep}{1cm}

\begin{document}
\maketitle

\begin{enumerate}
\item 演習時間外の質問もウエルカムです．73A2の周辺にいる学生，教員
      に！！
\item 全部理解できなくても前に進もう．そのうち必ずわ
      かるようになります．
\end{enumerate}

\section{昨日の補足情報}

\subsection{課題2 Makefile}

Makefileはmakeというプログラムの設定ファイルで，makeコマンドはMakefileに
書かれた依存関係と，その更新時間を調べ必要なコマンドを実行するものであ
る．課題2では

\begin{examplecode}
\small
 \begin{verbatim}
CC	= gcc
CFLAGS	= -O2 -Wall

.c.o:
        ${CC} -c ${CFLAGS} $<

all: play record

play: play.o soundlib.o
        ${CC} -o $@ $^

record: record.o soundlib.o
        ${CC} -o $@ $^

play.o: play.c soundlib.h
record.o: record.c soundlib.h
soundlib.o: soundlib.c soundlib.h

clean:
        rm play record play.o record.o soundlib.o
 \end{verbatim}
\end{examplecode}

というMakefileを作れればよい．行頭に7文字分のスペースがある部分はTabキー
を打つ．emacsだとM-iでもよい．

\begin{examplecode}
 \begin{verbatim}
record.o: record.c soundlib.h
 \end{verbatim}
\end{examplecode}
はrecord.cまたはsoundlib.h に更新があればrecord.o を作りなさい，というこ
とを言っており，そのときのルールは.cから.oを作るためのルールとして
\begin{examplecode}
 \begin{verbatim}
.c.o:
        ${CC} -c ${CFLAGS} $<
 \end{verbatim}
\end{examplecode}
に書かれている．このときの\$\{CC\}はgccを表し，\$\{CFLAGS\}は-O2 -Wallを表す
ことがMakefileの先頭に書かれている．すなわち中では
\begin{examplecode}
 \begin{verbatim}
gcc -c -O2 -Wall record.c
 \end{verbatim}
\end{examplecode}
が呼び出されrecord.oが作成される．
また，
\begin{examplecode}
 \begin{verbatim}
record: record.o soundlib.o
        ${CC} -o $@ $^
 \end{verbatim}
\end{examplecode}
では，record.oに更新があった場合
\begin{examplecode}
 \begin{verbatim}
gcc -o record record.o soundlib.o
 \end{verbatim}
\end{examplecode}
が呼び出されrecordを作成する．\$@はrecordに，\$\^はrecord.o soundlib.oに
それぞれ展開される．このルールは付録を見てほしい．

実際の挙動は，makeコマンドを実行することで
ファイルの先頭にあるターゲットルール(この場合はall:)が呼ばれ，
play または recordの依存関係が調べられる．
recordの依存関係はrecord.o と soundlib.o なので，さらに
これらの依存関係が調べられ
record.cまたはsoundlib.h に更新があればrecord.oをつくり，さらにrecordを
作る．また，soundlib.c soundlib.hに更新があるときにはsoundlib.oをつくり
同様にrecordを作る．

また，
\begin{commandline}
 \begin{verbatim}
% make clean
 \end{verbatim}
\end{commandline}
とするとcleanというターゲットに書かれてるrm play record play.o record.o soundlib.oが実行
される．

Makefile はコンパイルの手間を減らしてくれる効
果だけでなく，自分で書いたプログラムの構造を忘れてしまうことを防ぐ効果もある．
文法はむづかしくとっつきにくいが早めになれてほしい．
Makefileの基本的な仕組みについては\subsecref{Makefile}や
「\href{http://www.mech.t.u-tokyo.ac.jp/appliance/MechBook/enshu2008_ver10.pdf}{Mech環境利用の手引き}\footnote{\url{http://www.mech.t.u-tokyo.ac.jp/appliance/MechBook/enshu2008_ver10.pdf}．}(通称Mech本)」の6.5節を参照しよう．Mech環境利用の手引き他にも貴重な情報が含まれているので，ぜひ手元において折に触れて目を通してほしい．

\subsection{課題3.1, 3.2. 3.3　画像処理}

課題3.1はbとrをひっくり返すだけである．殆ど間違い探しなので慎重に比べてほ
しい．

\begin{examplecode}
\small
 \begin{verbatim}
      r = y + 1.40200 * v;
      g = y - 0.71414 * v - 0.34414 * u;
      b = y + 1.77200 * u;
      tmp[i * 3 + 0] = b;
      tmp[i * 3 + 1] = g;
      tmp[i * 3 + 2] = r;

      y = ((char *) buffers[0].start)[(i + 1) * 2];

      r = y + 1.40200 * v;
      g = y - 0.71414 * v - 0.34414 * u;
      b = y + 1.77200 * u;
      tmp[(i + 1) * 3 + 0] = b;
      tmp[(i + 1) * 3 + 1] = g;
      tmp[(i + 1) * 3 + 2] = r;
 \end{verbatim}
\end{examplecode}

課題3.2では２つのやり方がある．一つはカラー画像であるが，各画素に対応する
３色の値をすべてyの値とする方法である．これは以下のようになる．
\begin{examplecode}
\small
 \begin{verbatim}
      tmp[(i + 1) * 3 + 0] = y;
      tmp[(i + 1) * 3 + 1] = y;
      tmp[(i + 1) * 3 + 2] = y;
 \end{verbatim}
\end{examplecode}
もう一つは，カラー画像でなくグレー画像を作って，画像ファイルの数もwidth
* height * 3 ではなく，width * height にする方法である．
この場合は，以下のようにファイル形式をP6でなくてP5を与え
バッファのサイズもwidhth * heightし，ファイル名をtest.pgmとする．
\begin{examplecode}
\small
 \begin{verbatim}
void write_ppm()
{
    int i, fd_ppm;
    char tmp[width * height], header[256], fname[] = "test.pgm";

    (省略)

    sprintf(header, "P5\n%d %d\n255\n", width, height);

    (省略)

    for (i = 0; i < width * height; i++) {
        unsigned char y;
        y = ((char *) buffers[0].start)[i * 2];
        tmp[i] = y;
    }
    if (write(fd_ppm, tmp, width * height) < 0) {
        perror("write");
        exit(EXIT_FAILURE);
    }

    (省略)
}
 \end{verbatim}
\end{examplecode}

またグレー画像で各画素の値で二値化する課題3.3は以下のようにすればよい．
\begin{examplecode}
\small
 \begin{verbatim}
    for (i = 0; i < width * height; i++) {
        unsigned char y;
        y = ((char *) buffers[0].start)[i * 2];
        if (y < 128) {
            tmp[i] = 0;
        } else {
            tmp[i] = 255;
        }
    }
 \end{verbatim}
\end{examplecode}


\subsection{課題3.4 getopt\_long}

Unixではコマンドラインからコマンドに引数を与えることで実行を制御する仕組
みがある．例えば昨日の演習だと課題3等
では
\begin{commandline}
 \begin{verbatim}
% ./videocapture_mmap -bgr    ;; rgbのrとbをひっくり返した画像を出力
% ./videocapture_mmap -gray   ;; グレー画像を出力
% ./videocapture_mmap -binary ;; 二値化画像を出力
 \end{verbatim}
\end{commandline}
ということが出来ると，プログラムの管理も用意である．
アドバンスド課題1の1,2も同じように作りたいところだ．
まず以下のプログラムをgcc -o a.out test1.cとしてコンパイルし，
./a.out -n -v foo と実行してみよう．
\begin{examplecode}
\small
 \begin{verbatim}
main(int argc, char* argv[]) {
  int i;
  printf("%d arg(s) exists\n", argc - 1);
  for(i=0; i<argc; i++) {
    printf("argv[%d] is \"%s\".\n", i, argv[i]);
  }
} 
 \end{verbatim}
\end{examplecode}
\begin{commandline}
\small
 \begin{verbatim}
% gcc -o a.out test1.c
% ./a.out  -n -v foo
3 arg(s) exists
argv[0] is "./a.out".
argv[1] is "-n".
argv[2] is "-v".
argv[3] is "foo".
 \end{verbatim}
\end{commandline}
という結果が得られるはずだ．main 関数の引数であるargc と argv は，
それぞれ与えられた引数の数とそれぞれの文字列の配列である．

getoptはこのようなコマンドラインを簡単に取り扱うための関数である．
まずは以下のプログラムをtest2.cとして作成しよう．
\begin{examplecode}
\small
 \begin{verbatim}
#include <stdio.h> 
#include <unistd.h> 

int main(int argc, char *argv[]) { 
  int option; 
  while( 1 ){ 
    option = getopt(argc, argv, "nv:q"); 
    if( option == -1 ) break; 

    switch( option ){ 
      case 'n' : printf("Option %c.\n", option ); break; 
      case 'v' : printf("Option %c with arg %s.\n", option, optarg ); break; 
      case '?' : printf("Unknown option '%c'\n", optopt ); break; 
    } 
    optarg = NULL; 
  } 
}
 \end{verbatim}
\end{examplecode}

先程と同様にコンパイルし実行すると
\begin{commandline}
\small
 \begin{verbatim}
% gcc -o a.out test2.c
% ./a.out  -n -v foo
Option n.
Option v with arg foo.
 \end{verbatim}
\end{commandline}
となる．また，-n -v ではなく -nv としても
\begin{commandline}
\small
 \begin{verbatim}
% ./a.out  -nv foo
Option n.
Option v with arg foo.
 \end{verbatim}
\end{commandline}
以下のように同じ結果を得ることが出来る．

man で見るとgetopt 関数は 
\begin{examplecode}
\small
 \begin{verbatim}
int getopt(int argc, char * const argv[], const char *optstring) 
extern char *optarg; 
extern int optind, opterr, optopt; 
 \end{verbatim}
\end{examplecode}
となっている．argc, argvはmain関数の引数を渡せばよくoptstringは
受け付けるオプション文字からなる文字列である．文字のあとにコロン (:) が
置かれている場合はオプションには引き数が必要であることを示している．
ここでは，"nv:q"となっているので，オプション文字として''-n, -v, -q''
を受け取ることができ，かつ''-v''は引数を必要とするということを意味してい
る．optargは引数があるときは引数の文字列へのポインタであり，optindは
現在処理しているargv[]の添え字であり，opterr,optoptはエラー時の処理に利
用する．返り値はオプション文字であり，これ以上引数が存在しない場合は-1が
帰ってくる．

getopt\_longは''--value''などの文字列からなるオプションに対応したものであ
る．宣言は，

\begin{examplecode}
\small
 \begin{verbatim}
int getopt_long(int argc, char * const argv[],
           const char *optstring,
           const struct option *longopts, int *longindex);
 \end{verbatim}
\end{examplecode}
となっており，optstringはgetoptと同じである．longoptsは
struct option の要素からなる配列の先頭要素へのポインタである．
longindexはNULL でなければ長いオプションのインデックスを longopts から
      の相対位置として保持している変数へのポインタとなる． 
 struct option は以下のように定義されている。 
\begin{examplecode}
\small
 \begin{verbatim}
struct option {
   const char *name;
   int has_arg;
   int *flag;
   int val;
};
 \end{verbatim}
\end{examplecode}
\begin{itemize}
\setlength{\parskip}{0cm}
\setlength{\itemsep}{0cm}
\item [name]{長いオプションの名前}
\item [has\_arg]{no\_argument (または 0) ならオプションは引き数をとらな
      い． required\_argument (または 1) ならオプションは引き数を必要と
      する． optional\_argument (または 2) ならオプションは引き数をとっ
      てもとらなくても良い．}
\item [flag ]{長いオプションに対する結果の返し方を指定する．flag が NULL
      なら getopt\_long() は val を返すNULL 以外の場
      合には、getopt\_long() は 0 を返す．
%このときオプションが見つかると      flag がポイントする変数に val が代      入される．見つからないとこの変数      は変更されない． 
      }
\item [val]{返り値または flag がポイントする変数へロードされる値。}
\end{itemize}
getopt\_long を使ったサンプルプログラム(test3.c)は以下のよう
になる．
\begin{examplecode}
\small
 \begin{verbatim}
#include <stdio.h> 
#include <unistd.h> 
#include <getopt.h>

int main(int argc, char *argv[]) { 
  int option; 
  static struct option long_options[] = {
    {"null", no_argument, NULL, 'n'},
    {"value", required_argument, NULL, 'v'},
    {0, 0, 0, 0}};
  while( 1 ){ 
    int index;
    option = getopt_long(argc, argv, "nv:q", long_options, &index); 
    if( option == -1 ) break; 
    switch( option ){ 
      case 'n' : printf("Option %c.\n", option ); break; 
      case 'v' : printf("Option %c with arg %s.\n", option, optarg ); break; 
      case '?' : printf("Unknown option '%c'\n", optopt ); break; 
    } 
    optarg = NULL; 
  } 
}
 \end{verbatim}
\end{examplecode}

先程と同様にコンパイルし実行すると
\begin{commandline}
\small
 \begin{verbatim}
% gcc -o a.out test3.c
% ./a.out  --null --value foo
Option n.
Option v with arg foo.
 \end{verbatim}
\end{commandline}
となる．以下のようなコマンドでも同じ結果を得ることが出来る．
\begin{commandline}
\small
 \begin{verbatim}
% ./a.out  --null --value foo
% ./a.out -n --value foo
% ./a.out --null -v foo 
% ./a.out -n -v foo
 \end{verbatim}
\end{commandline}

さて，それでは課題4.3を見てみよう．例えば
\begin{examplecode}
\small
 \begin{verbatim}
static const struct option long_options[] = {
  {"device", required_argument, NULL, 'd'},
  {"output", required_argument, NULL, 'o'},
  {"width", required_argument, NULL, 'w'},
  {"height", required_argument, NULL, 'e'},
  {"help", no_argument, NULL, 'h'},
  {0, 0, 0, 0}
};
 \end{verbatim}
\end{examplecode}
として，``-o newimage.ppm''や``--output newimage.ppm''でファイル名を
引数で与えたい．videocapture.cは以下のようにコードを追加すればよい．
\begin{examplecode}
\small
 \begin{verbatim}
main (int argc, char **argv) {
  dev_name = "/dev/video";
  char *fname = "test.ppm";

  for (;;) {
     (省略)
      c = getopt_long (argc, argv, "d:o:w:e:h", long_options, &index);
      if (c == -1)
        break;
      switch (c) {
        (省略)
        case 'o':
          fname = optarg;
          break;
        (省略)
     }
  }
  (省略)
  write_ppm (fname);
  (省略)
}
 \end{verbatim}
\end{examplecode}

これに対応し，write\_ppm関数を
\begin{examplecode}
 \begin{verbatim}
void
write_ppm (char *fname)
{
  int i, fd_ppm;
  char tmp[width * height * 3], header[256];
 \end{verbatim}
\end{examplecode}
とすればよい．

\section{本日の演習の目的}

本日の演習では，コンピュータ同士の通信に広く使用されているソケット通信
を学ぶ．メールやウェブ等のインターネットを介した通信のプログラムは，
「ソケット」というプログラミングインタフェースを用いてプログラムできる．

\section{ネットワーク通信}
今日ネットワーク通信と言えば，IP(インターネットプロトコル)による通信で
ある．メール・ウェブ・インスタントメッセンジャー等は，全てIPによる通信
である．IPによる通信はサーバ・クライアント型で，クライアントからの接続
を待ち受けるサーバプログラムに，クライアントプログラムが接続して，双方
向の通信が可能になる．

\subsection{IPアドレス}
IPアドレスとは，IPネットワーク上で通信相手(ホスト)を識別するための番号
のことで，12.34.56.78 のように0〜255(8ビット)の4つの数値をピリオドで区
切った列として表記される\footnote{32ビットなので最大4G個のアドレスとい
うことになる．}．

インターネット通信を行う全てのコンピュータは，IPアドレスを持っている．
世界中のどこからでも一意に識別できるアドレスはグローバルIPアドレスと呼
ばれ，組織毎に設定してよいアドレスの範囲が割り当てられている．これに対
し，組織内や家庭内などで外から見えないネットワークで使用可能なIPアドレ
スをプライベートIPアドレス\footnote{プライベートIPアドレスとして使用し
てよいアドレス範囲として，
10.0.0.0〜10.255.255.255，172.16.0.0〜172.31.255.255，
192.168.0.0〜192.168.255.255のアドレス空間が予約されている．}と呼ぶ．

演習室13B室のデスクトップPCは，外部のネットワークからは直接アクセスで
きないプライベートIPアドレスを使用している．例えば，mechpc37のIPアドレ
スは，10.1.1.37である\footnote{外部のウェブサイトを見る際などは，
mech-gw.mech.t.u-tokyo.ac.jpというコンピュータでアドレスが変換され，
mech-gw.mech.t.u-tokyo.ac.jpからのアクセスという形でアクセスされる．}．

自分自身のIPアドレスを調べるコマンドはifconfigである．
wlan0というエントリ以下のようになっていれば，
このマシンのIPアドレスが157.82.5.198ということがわかる．
\begin{commandline}
\small
 \begin{verbatim}
% ifconfig
（省略）
wlan0     Link encap:Ethernet  HWaddr 00:13:E8:BC:EB:A7  
  注目→  inet addr:157.82.5.198  Bcast:157.82.7.255  Mask:255.255.252.0
          inet6 addr: fe80::213:e8ff:febc:eba7/64 Scope:Link
          UP BROADCAST RUNNING MULTICAST  MTU:1500  Metric:1
          RX packets:14137 errors:0 dropped:0 overruns:0 frame:0
          TX packets:621 errors:0 dropped:0 overruns:0 carrier:0
          collisions:0 txqueuelen:1000 
          RX bytes:2160461 (2.0 Mb)  TX bytes:78112 (76.2 Kb)
 \end{verbatim}
\end{commandline}
wlan0というエントリがなければデバイスドライバが入っていない状態であり，
inet addr... という行がなければネットワークに接続がなされていない．
あまり薦められる方法ではないが，手前のデスクトップの有線ケーブルを抜いて
ノートPCにさせばよい．もしネットワークに接続がなされない状況であれば，
\begin{commandline}
\small
 \begin{verbatim}
% sudo /etc/init.d/network restart
 \end{verbatim}
\end{commandline}
としてネットワーク関連のソフトウェアの再起動をしてみる．これでもだめなら，
線を抜いたデスクトップのIPアドレスを調べ，これが例えば10.1.1.99
だとすると，
\begin{commandline}
\small
 \begin{verbatim}
% sudo ifconfig eth0 10.1.1.99
 \end{verbatim}
\end{commandline}
とすれば，ノートＰＣのIPアドレスは10.1.1.99になる．
これらの作業でパスワードを求められたらノートPCにログインする際のパスワードを入力する．


\subsection{ホスト名}
IPアドレスを人間に識別しやすいように，IPアドレスの代わりに「ホスト名」
「ドメイン名」を用いることができる(ホストとはIP通信を行うコンピュータ
のことである)．www.jsk.t.u-tokyo.ac.jp のようなホストの指定の仕方を，
「ホスト名」や「FQDN」(FQDN = Fully Qualified Domain Name) と呼ぶ．
www.jsk.t.u-tokyo.ac.jp には，jsk.t.u-tokyo.ac.jpという「ドメイン名」
を持つコンピュータ群(ネットワーク)の中の，wwwという「ホスト名」を持つ
コンピュータという意味がある．ドメイン名とホスト名の組み合わせにより，
世界中のコンピュータのうちの1台を特定することができる．

\subsection{DNSサーバ(ネームサーバ)}
ホスト名を，IPアドレスに変換する作業を行うサーバ(これ自身もIPアドレス
を持ったコンピュータである)のことを，DNS(Domain Name System)サーバと呼
ぶ．ブラウザなどに入力されたホスト名は，DNSサーバに問い合わせてIPアド
レスに変換され，そのIPアドレスに対してブラウザはアクセスを行う．

nslookup というコマンドを使うと\footnote{最近はdigというコマンドも使わ
れる．}，DNSサーバへの問い合わせを行うことができる．

www.jsk.t.u-tokyo.ac.jp に対応する IP アドレスを知りたいときは，
\begin{commandline}
 \begin{verbatim}
% nslookup www.jsk.t.u-tokyo.ac.jp
Server:   xxx
Address:  xxx.xxx.xxx.xxx

Name:     www.jsk.t.u-tokyo.ac.jp
Address:  157.82.13.119
 \end{verbatim}
\end{commandline}
のようにして，157.82.13.119 であることがわかる．

逆に，あるIPアドレスxxx.xxx.xxx.xxxについて，
\begin{commandline}
 \begin{verbatim}
% nslookup xxx.xxx.xxx.xxx
 \end{verbatim}
\end{commandline}
とすればそのIPアドレスが指定するホストのホスト名を知ることができる．

\subsubsection{ポート番号}
IP(インターネットプロトコル)による通信を行うコンピュータを特定して通信
を開始するには，IPアドレスの他に「ポート番号」を指定する必要がある．

クライアントからの接続を待ち受けるサーバプログラムは，特定のポート番号
への接続を待ち受ける．ポート番号は，0〜65535(16bit)の整数値である．

サーバへ接続するクライアントプログラムは，サーバプログラムが実行されて
いるホストとポート番号を指定して，接続を試みる．

インターネットにおける各種サービスを行うサーバプログラムは，サービスに
よってどのポート番号への接続を待ち受けるかが原則として決まっている．
例えば，ウェブサーバは80番ポートへの接続を待ち受け，メールは25番ポート
への接続を待ち受ける．80番ポートではhttpというプロトコルを解釈し，
GETはwebサーバから文書を要求するためのhttpのコマンドであり，
80番ポートに接続しGETコマンドを送ることでwebの文章をダウンロードできる．
httpの詳細な仕様は\url{http://www.studyinghttp.net/cgi-bin/rfc.cgi?2616}の5.1, 9.3節に書いてある．


\begin{excersize}{練習1}
 \begin{enumerate}
  \item nslookup を利用して，www.u-tokyo.com の IP アドレスを調べてみよ．
  \item IP アドレス，133.11.128.254 のFQDN を調べてみよ．
  \item telnetコマンドを利用すると，ホスト名とポート番号を指定して，サー
  バプログラムに接続することが可能である．
  どこかのウェブサーバの80番ポートにアクセスしてみよう．
  \begin{verbatim}
    % telnet www.jsk.t.u-tokyo.ac.jp 80
    GET /index.html /HTTP1.1 <ENTER><ENTER>
    (<ENTER><ENTER>はEnterを二回押すという意味)
    ...
  \end{verbatim}
 \end{enumerate}
\end{excersize}


\section{ソケットを用いたプログラミング(サーバ)}

「ソケット」とは，UNIX系のシステムでネットワークを介して通信を行うCプ
ログラムのための関数群(API)である．

通信の送受信は，前回のデバイス制御のように，\verb+read+, \verb+write+
を使ってデータの送受信を行うことができるが，\verb+open+に相当する部分
は若干異なる手続きが必要になる．

ソケットを利用した通信プログラムを書くための関数には以下のようなものが
ある．
\begin{description}
\item [socket()] ネットワーク通信のどちらかの端となる口を作成する．サー
  バ・クライアント共に使用．
\item [connect()] socket()で作成したソケットから，IPアドレスとポート番
  号を指定して，サーバに接続する．クライアント側が使用．
\item [bind()] socket()で作成したソケットに，IPアドレスとポート番号を
  設定する．サーバ側が使用．
\item [listen()] bind()でIP・ポート番号を割り当てたソケットで，クライ
  アントからの接続要求を受けられる状態にする．サーバ側が使用．
\item [accept()] bind()されlisten()の状態になったソケットに，クライア
  ントから接続要求が来ていれば，接続を確立しread(), write() が可能なファ
  イルディスクプリタを返す．クライアントから接続要求が来ていなければ来
  るまで待つ．サーバ側で使用．
\end{description}

\subsection{socket():ソケットの作成}
ソケットを用いて通信プログラムを書く場合，通信の両端に相当する部分を作
成するのが，\verb+socket+関数である．サーバもクライアントも，まず
\verb+socket+関数を用いて接続口を作成する．作成に成功すると割り当てら
れたディスクプリタ(整数値)を返す．コマンドラインから，
\begin{verbatim}
  % man 2 socket
\end{verbatim}
とすると，\verb+socket+関数のオンラインマニュアルを読むことができる．

\begin{examplecode}
 \begin{verbatim}
#include <sys/socket.h>

int socket(int socket_family, int type, int protocol);

socket_family : PF_INETはインターネット型
socket_type   : SOCK_STREAMはTCP
protocol      : 通常は 0 を指定
返値          : 成功の場合はディスクプリタ．失敗の場合は-1．
 \end{verbatim}
\end{examplecode}

\subsection{struct sockaddr\_in構造体}
\subseclabel{sockaddr}
\verb|struct sockaddr_in|は以下のような構造体である．
インターネットドメインでのホスト情報を格納する構造体である．
\begin{examplecode}
\begin{verbatim}
struct sockaddr {
     short          sin_family;  // 通常PF_INET
     unsigned short sin_port;    // ポート番号
     struct in_addr sin_addr;    // IPアドレス
};

\end{verbatim}
\end{examplecode}

\subsection{bind():ソケットへのIPアドレス・ポート番号の割り付け}

\begin{examplecode}
 \begin{verbatim}
#include <sys/socket.h>

int  bind(int  s, struct sockaddr *my_addr, socklen_t len);

s           : ソケットのディスクリプタ
my_addr     : IPやポート番号の情報を格納する構造体へのポインタ
len         : my_addr(構造体)のサイズ
返値        : 成功(0)か否か(-1)
 \end{verbatim}
\end{examplecode}
socket()で作成したソケット(通信の末端)に，IPアドレスとポート番号を割り当てる．
\verb|sockaddr_in|構造体は\subsecref{sockaddr}の構造体である．

\subsection{listen():クライアントからの接続受付開始(ソケットキュー(待ち行列)の作成)}

\begin{examplecode}
 \begin{verbatim}
#include <sys/socket.h>

int listen(int s, int backlog);

s        : ソケットのディスクリプタ
backlog  : 待ち行列の長さ
返値     : 成功(0)か否か(-1)
 \end{verbatim}
\end{examplecode}
ソケットキュー(待ち行列)を作成し，クライアントからの接続要求に応える事
ができるようにする．その接続可能なクライアントの最大数を 
\verb|backlog|で指定する．一対一の通信の場合には，\verb|backlog| は1で
良い．クライアントからの接続要求は，ソケットキューに自動的に入り，次の
処理，\verb|accept|(\subsecref{accept})を待つことになる．

\subsection{accept():接続要求を受け入れ，その接続用のファイルディスク
  プリタを発行}
\subseclabel{accept}

\begin{examplecode}
 \begin{verbatim}
#include <sys/socket.h>

int accept (int s, struct sockaddr_in *addr, int *addrlen);

s        : ソケットのディスクプリタ
addr     : クライアントの情報の受け取りポインタ(受け取らないならNULL)
addrlen  : クライアントの情報の長さ(受け取らないならNULLでOK)
返値     : 成功の場合は新しいファイルディスクリプタ，失敗の場合は-1
 \end{verbatim}
\end{examplecode}

ソケットキューに入っているクライアントからの接続要求を取り出し，新しい
ファイルディスクリプタを生成して実際に接続する．今後，データのやりとり
を行う場合，新しいファイルディスクリプタを使用することとなる．

\subsection{演習用ソース等一式のダウンロード}
\subseclabel{tgz}
今回も計算機演習のWebページ
(\url{http://www.isi.imi.i.u-tokyo.ac.jp/lectures/pukiwiki/keisanki})から計算機演習のリンクをたどり，
\verb|enshu-20090605.tgz|をダウンロードし，以下のコマンドを実
行し必要なファイルを入手しよう．
\begin{commandline}
 \begin{verbatim}
% tar xvzf enshu-20090605.tgz
% cd enshu-20090605/socket
 \end{verbatim}
\end{commandline}
ちなみにダウンロードはコマンドラインから
\begin{commandline}
 \begin{verbatim}
% wget http://www.jsk.t.u-tokyo.ac.jp/~k-okada/lecture/enshu-20090605.tgz
 \end{verbatim}
\end{commandline}
とすることでも出来る．

\begin{excersize}{課題1}
  \begin{enumerate}
  \item \subsecref{tgz}で展開したディレクトリの enshu-20090605/socket へ
	移動し，make コマンドにより server-nomulti がコンパイルされるこ
	とを確認せよ．
  \item ./server-nomulti としてサーバプログラムを立ち上げ，telnetコマン
	ドによりこのサーバプログラムに通信できることを確認しよう．
 \end{enumerate}
\end{excersize}

サーバへのアクセスは\verb+telent localhost <ポート番号>+ である．
server-nomultiを作るためのソースプログラムserver-nomulti.c
socketlib-nomulti.h, socketlib.h をみてこのプログラムのポート番号を
調べればよい．
また，telnetでプログラムにつなげた跡は，C-]とすればtelnet＞という
	プロンプトに帰ってくるのでここでquitと打ち込むとプログラムから終
	了できる．ちなみに
	localhostは自分自身（プログラムが実行しているマシン）を表すホス
	ト名である．これのIPアドレスは127.0.0.1になる．

\section{ソケットを用いたプログラミング(クライアント)}

\subsection{connect():サーバへの接続要求}
単純なクライアントは，\verb+socket+関数によりソケットを作成し，
\verb+connect+関数によりサーバに接続する．コマンドラインか
ら，
\begin{verbatim}
  % man 2 connect
\end{verbatim}
とすると，\verb+connect+関数のオンラインマニュアルを読むことができる．

\begin{examplecode}
 \begin{verbatim}
#include <sys/socket.h>

int  connect(int s, struct sockaddr_in *serv_addr, int len);

s         : ソケットのディスクプリタ(socket関数の返値)
serv_addr : サーバホストの情報(IPアドレス，ポート番号)が格納されている構造体
len       : serv_addr(構造体)のサイズ
返値      : 成功(0)か否か(-1)
 \end{verbatim}
\end{examplecode}

構造体\verb|serv_addr|にはあらかじめ，接続する先のサーバの情報(IPアド
レスおよびポート番号)を設定しておく．\verb|len|にはその，
\verb|struct sockaddr_in|構造体のサイズを指定する．今後データのやりと
りを行う場合には，ソケット\verb|s|をファイルディスクリプタと同様に扱い，
\verb|read|，\verb|write|システムコールによって行う．

\begin{excersize}{課題2}
  \begin{enumerate}
  \item 課題2で作成した Makefile を修正し，clinet-nomulti.o と socketlib-nomulti.o か
  ら実行可能ファイル\verb+client-nomulti+を作成する部分を追加せよ．
  makeとすれば，\verb+client-nomulti+と\verb+server-nomulti+の両方が作成されるようにす
  ること．
  \item client-nomulti.c は，クライアントのサンプルプログラムであるが未
	完成である．/** TODO **/に適切な値をいれ，完成させよ．
  \item
   課題1で
    作成したサーバプログラムにアクセスしてみよ．誰か別の人のプ
    ログラムと通信をしてみると良い．\newline
    ヒント：自分自身のIPアドレスは127.0.0.1である．
 \end{enumerate}
\end{excersize}

\subsection{ソケット通信における送受信の注意}

ソケット通信では，大量のデータを一度に送受信しようとしてもうまく動作し
ないことがある．一度に送受信できるデータのサイズはネットワークの混雑状
態などに依存しており，問題がなければ一度に100Kbyte 送受信できることも
あるが，混雑しているときは1byte しか送受信することができない場合もある．
このため，\verb|read|での受信，\verb|write|での受信，の際，その返り値
を参照して再送(または再受信)を行う必要がある．例えば，256byte を送信し
たい場合に，\verb|write|の返り値が100だった場合，残り156byteが未送信状
態なので，このデータを再送信する必要がある．
socketlib-nomulti.c(\ref{ssec:src:socketlib-nomulti.c})の\verb+socket_read()+と
\verb+socket_write()+は，この仕組みを実装したコードである．


\begin{excersize}{アドバンスド課題}
  余力がある人や理解を深めたい人は，次の課題に挑戦してみよう．
  \begin{enumerate}
  \item キャプチャした画像をネットワークを通して送信し，別のコンピュータ
	で受信し表示するプログラムを作成せよ．
  \item
  クライアントとサーバの間で１対１のテキストチャットを行えるようなプロ
  グラム \verb+text_chat_server+ と \verb+text_chat_client+ を作成せよ．
  \begin{itemize}
  \item キーボードから文字列を入力すると接続したもう一台のコンピュータ
    に送信され，そちらのコンピュータに表示されるようにする．ただし，文
    字列はサーバとクライアントとで交互に送信する．
  \item プログラムを終了・再起動することなく，何回でも通信が行えるよう
    にし，どちらかが qで始まる文字列を送信すると，通信を終了するように
    せよ．
  \item 送受信するデータのサイズは，固定長にし，socketlib.c の
    \verb+socket_write()+ 及び \verb+socket_read()+ を用いて通信するの
    が良い．ネットワーク通信は，\verb+read()+や\verb+write+で指定した
    バイト数より少ないデータ量の通信でも，\verb+read()+や\verb+write+
    の実行が終了する場合があるためである．
  \item クライアントは，起動時に引数で，接続するサーバのIPアドレスとポー
  ト番号を指定できるようにすること．起動時に引数を与えなければ，デフォ
  ルトのIPアドレスとポート番号をを用いるようにすること．\\
  文字列(char*)から整数(int)への変換は，
  \verb+int atoi(const char *str);+を用いることができる．
  \item enshu-20090605/socket/ で make すると，これまでの全てのアプリケー
    ション(実行可能プログラム)が生成されるような Makefile にすること．
  \end{itemize}
  \item ウェブサーバのIPアドレスを指定すると，/index.html を GET し，
    その内容をファイルに保存するプログラムを作成せよ．
  \item IPアドレスでなくホスト名を指定して，通信ができるようなクライア
    ントプログラムを作成せよ．gethostbyname()関数について調べて利用す
    ると良い．
 \end{enumerate}
\end{excersize}

\appendix
\section{Makefile}
\seclabel{Makefile}
\subseclabel{Makefile}

\subsection{Makefile基本}

Makefile のルールの基本は次の形である．
\begin{screen}
\begin{verbatim}
ターゲット:依存するファイル
        コマンド
\end{verbatim}
\end{screen}
コマンドラインから 
\begin{screen}
\begin{verbatim}
make (ターゲット)
\end{verbatim}
\end{screen}
とすることで，「ターゲット」が存在しない，あるいはターゲットよりも新しい「依存するファイル」場合にコマンドが
実行される．また，コマンド行の始まりは必ずタブコードを書く．
したがってtest1 が main.c と hello.c からコンパイルされる場合は以下のように記述する．
\begin{screen}
\begin{verbatim}
test1.exe: main.c hello.c 
        gcc -o test1.exe main.c hello.c
\end{verbatim}
\end{screen}

これでコマンドラインから以下のように打ち込めばコンパイルができる．
\begin{screen}
\begin{verbatim}
% make test1.exe
gcc -o test1.exe main.c hello.c
\end{verbatim}
\end{screen}

\subsection{依存関係の記述}

上の例ではhello.cが更新された場合でもmain.cのコンパイルが行われてしまい，非効率である．
これを回避するためには以下のように main.c から main.o を作るルールと,
hello.c から hello.o を作るルールをMakefileに書き， test2 は hello.o
と main.o から作られるようにする．そうすると，hello.cが更新された場合，
\verb|make test2|とするとhello.cのみ再コンパイルされ，不要なmain.cの再
コンパイルは行われない．

\begin{screen}
\begin{verbatim}
test2.exe: main.o hello.o
        gcc -o test2.exe main.o hello.o
main.o: main.c
        gcc -o main.o -c main.c 
hello.o: hello.c
        gcc -o hello.o -c hello.c 
\end{verbatim}
\end{screen}



\subsection{自動変数}

ルールを書くときに同じことを何回も書くことを避けるために，
自動変数が用意されている．


\begin{screen}
\begin{verbatim}
test3.exe: main.o hello.o
        gcc -o $@ $^
main.o: main.c
        gcc -o $@ -c $^
hello.o: hello.c
        gcc -o $@ -c $^
\end{verbatim}
\end{screen}

\begin{description} 
\item [\$@] ターゲットのファイル名，\verb+$^+は依存するファイル名であ
  るため，このmakefileは上の例と同じことになる．
\item [\$\%] ターゲットがアーカイブメンバだったときのターゲットメンバ名
\item [\$＜] 最初の依存するファイルの名前
\item [\$?] ターゲットより新しいすべての依存するファイル名
\item [\$＾] すべての依存するファイルの名前
\item [\$+] Makefileと同じ順番の依存するファイルの名前
\item [\$*] サフィックスを除いたターゲットの名前
\end{description}

さらに，\verb|ファイル名.c|からは\verb|ファイル名.o|を作るルールは，次
のように書ける．
\begin{screen}
\begin{verbatim}
.c.o:
        gcc -o $@ -c $<
最近は，以下のように書くことも多い．
%.o: %.c
        gcc -o $@ -c $<
\end{verbatim}
\end{screen}
こうすると汎用なルールになり，Makefileは以下のように４行でシンプルに書
くことができる．
\begin{screen}
\begin{verbatim}
test4.exe: main.o hello.o
        gcc -o $@ $^
%.o: %.c
        gcc -o $@ -c $<
\end{verbatim}
\end{screen}

Makefileは奥が深いので，色々と調べてみると良い．
たとえば，
\url{http://www.jsk.t.u-tokyo.ac.jp/~k-okada/makefile/}
は参考になるだろう．
また，奥が深いものに対する考察は
\url{http://0xcc.net/misc/bad-knowhow.html}
が面白い．


\section{コーディングスタイルについて}

プログラムの可読性，保守性をあげるには見た目の重要である．
つまり，どこでインデント（字下げ）をして，どこで改行するか
などのルールを決めるとよい．このルールをコーディングスタイルという．

たとえば，簡単なプログラムとして以下のプログラムを見てみよう．
\begin{commandline}
\small
 \begin{verbatim}
int main () {
     int i = 0;
  for ( i = 0; i < 10; i ++ ) {
fprintf("helloworld %d\n", i);
        }
}
 \end{verbatim}
\end{commandline}
このようにインデントがづれている場合，emacs上で各行でTabキーを押せば，
正しいインデントに直してくれる．あるいは，最初の行でCtrl-Space\footnote{
C-Spaceで日本語入力モードになってしまう場合は，右下のキーボードアイコン
で右クリックを押し，SCIMを設定を開く．フロントエンドの全体設定を選択し開
始/終了一番右の...というボタンを押す．設定済みのキーというダイアログの
Control+spaceという部分を選択し，右下の削除というボタンを押せばよい．
}を
押し，C-nを6回押してM-x indent-regionとすると，以下のようにきれいにイン
デントがそろうようになる\footnote{C- はコントロールキーを押しながら，M-
はエスケープキーを押しながら，という意味である．}．
\begin{commandline}
\small
 \begin{verbatim}
int main () {
  int i = 0;
  for ( i = 0; i < 10; i ++ ) {
    printf("helloworld %d\n", i);
  }
}
 \end{verbatim}
\end{commandline}
さらに，汚い以下のようなプログラムの場合はindentというコマンドがある．
\begin{commandline}
\small
 \begin{verbatim}
int main () {     int i = 0;
  for ( i=   0; i < 10; i++) {
printf("helloworld %d\n", i);          }
}
 \end{verbatim}
\end{commandline}
indentコマンドはインデントだけでなく改行なども修正してくれる．
\begin{commandline}
\small
 \begin{verbatim}
% indent main.c -o main2.c
 \end{verbatim}
\end{commandline}
とすると，main.cというファイルを整形しmain2.cというファイルを作ってくれ
る．
\begin{commandline}
\small
 \begin{verbatim}
% indent main.c
 \end{verbatim}
\end{commandline}
とすると，main.cというファイル自身を修正する．

また，indentコマンドではコーディングスタイルを選択できる．標準は
\begin{commandline}
\small
 \begin{verbatim}
% indent -gnu main.c
% cat main.c
int
main ()
{
  int i = 0;
  for (i = 0; i < 10; i++)
    {
      printf ("helloworld %d\n", i);
    }
}
 \end{verbatim}
\end{commandline}
というGNUのスタイルだが，
\begin{commandline}
\small
 \begin{verbatim}
% indent -kr main.c
% cat main.c
int main()
{
    int i = 0;
    for (i = 0; i < 10; i++) {
        printf("helloworld %d\n", i);
    }
}
 \end{verbatim}
\end{commandline}
というようなカーニハン＆リッチーのＣ言語教科書風スタイル，
あるいは，
\begin{commandline}
\small
 \begin{verbatim}
% indent -orig main.c
% cat main.c
int
main()
{
    int             i = 0;
    for (i = 0; i < 10; i++) {
        printf("helloworld %d\n", i);
    }
}
 \end{verbatim}
\end{commandline}
という昔のバークレイスタイルを選択できる．


\section{構造化プログラミングの技法}

今後プログラムを書いて行く上でぜひとも気にしてほしい点をリストアップして
みる．

\subsection{関数を長くしない}

一つの関数（特にmain関数）を長く書いて行くと，どのような制御構造であったか，どのようなプログラムの流れで
あったかを，自分でも忘れるし，プログラムを眺めても良く分からない．

そこで決まった動作をするブロックや，あるひとまとまりの意味を持つブロックをサブルーチンとして
別の関数にし，どんな挙動をしているのかが自分で読んで理解できるようにまとめあげることが大切であると言われている．

ちなみに，ある一つの目安として，１画面に収まらないようなくらいの長さの関数は，既に長すぎると思った方が
良いと言われている．今週の課題はそれに気を付けながら進めると良いだろう．

\subsection{グローバル変数を多用しない}

グローバル変数は構造化プログラミングの敵である．グローバル変数は先の説明の通り，画面の中で閉じて物事を
考えることを阻止するからである．グローバル変数が使いたい場合には，複数の共通の目的に用いられる変数を
構造体としてまとめ，その構造体を\verb|main|関数のスコープの中で定義し，サブルーチンにその構造体への
ポインタを渡すことで情報を伝える，という技法が推奨される．この方法を用いると，いつ，どの関数が，
どんな情報を更新したり修正したりしているかが，理解しやすくなるため，バグの発生率が低くなる効果がある．



\section{ソースコード}

\subsection{socketlib-nomulti.h：ソケット通信関連ヘッダファイル\label{ssec:src:socketlib.h}}

{\scriptsize
\listinginput[1]{1}{enshu-20090605/socket/socketlib.h.sjis}
}

\subsection{socketlib-nomulti.c：ソケット通信関連関数\label{ssec:src:socketlib-nomulti.c}}

{\scriptsize
\listinginput[1]{1}{enshu-20090605/socket/socketlib-nomulti.c.sjis}
}

\subsection{server-nomulti.c：サーバプログラム\label{ssec:src:serverno-multi.c}}

{\scriptsize
\listinginput[1]{1}{enshu-20090605/socket/server-nomulti.c.sjis}
}

\subsection{client-nomulti.c：クライアントプログラム(要修正)\label{ssec:src:client-nomulti.c}}

{\scriptsize
\listinginput[1]{1}{enshu-20090605/socket/client-nomulti.c.sjis}
}

\end{document}
