\documentclass[a4j,twoside]{jarticle}
%% \documentclass[9pt]{jltxdoc}
%% \documentclass[9pt]{jarticle}
%docinfo.txtにPDFに変換するときの情報を入れる
\input docinfo.out

\usepackage[dvipdfm]{graphicx}
\usepackage{array, amsmath, amssymb, ascmac, supertabular, moreverb, multicol}
\usepackage[dvipdfm]{hyperref}
\hypersetup{urlbordercolor={1 1 1}}
\hypersetup{bookmarksnumbered=true}
\hypersetup{linkcolor={0 0 0}}
%%\hypersetup{linkbordercolor={white white white}}
\hypersetup{linkbordercolor={1 1 1}}
\hypersetup{colorlinks=false}
\pagestyle{headings}

%講義・演習配布資料用設定集 from k-okada
\usepackage{enshu-lec}
%\usepackage{doc}

\title{2011年度　機械情報工学科　冬学期演習\\
ロボット行動プログラミング(1)}
\author{
　　　　担当教員: 岡田慧准教授(k-okada@jsk.t.u-tokyo.ac.jp),\\
　　　　　　　　　中西雄飛助教(nakanish@jsk.t.u-tokyo.ac.jp),\\
山口真奈美技術専門職員\\
TA:情報システム工学研究室\\
}
\date{平成２３年１２月５日(月)}
\setlength{\columnseprule}{0.5pt}
\setlength{\columnwidth}{.3\textwidth}
\setlength{\columnsep}{1cm}

%\renewcommand{\baselinestretch}{0.95}

\begin{document}
\maketitle

\section{ロボット行動プログラミング}
冬学期演習，移動台車ロボットを使う演習の最後のまとめとして，
これまで学習してきた様々な内容を含んだ統合的課題を5回行う．
内容は全方位移動機構，USBカメラ，多軸アームからなる移動台車ロボットを用い，
画像処理やその他のセンサ処理に基づいて環境を理解し，その結果に基づき環境中を自由に移動し，
アームを駆使して環境に対して作用するロボットの行動プログラミング演習である．
ロボット制御プログラミングと同様のグループ分けを行い演習を進めていく．

全5回の内容は以下のような予定になっている．
\begin{enumerate}{\itemsep=-4pt
\item {\bf 第1回 12月5日 ロボット行動プログラミング(1)}\\
  サーバ・クライアントシステムとシミュレータ環境
\item {\bf 第2回 12月6日　ロボット行動プログラミング(2)}\\
  USBカメラでの画像取得，画像処理サーバを用いたロボット行動プログラム\\
  逆運動学を用いたアーム制御，ジョイスティックによる操縦制御
\item {\bf 第3回 12月9日　感覚行動プログラミング}\\
  サブサンプションアーキテクチャの利用，スレッド行動制御
\item {\bf 第4回 12月12日 競技説明，試走会}
\item {\bf 第5回 12月13日 競技実施，表彰式，反省会}
}
\end{enumerate}

%%
\section{本日の演習内容}
本日の目的は，全５回の演習を進める上で，
各々が自発的に(自力で)簡単に，ロボットでセンサに基づく反応行動を
記述できるようになるための基礎を学んでもらうことである．
具体的には，ロボットの行動制御開発を容易に行うための以下の二つ
についての意味・構成を理解してもらうと供に，プログラムの動かし方
作り方を学んでもらう．
\begin{itemize}{\itemsep=-4pt
\item \bf {サーバ・クライアント方式のロボットシステム}
\item \bf {実ロボットと透過なシミュレータ環境}
}\end{itemize}
今回は穴埋めや高度なプログラムを書いてもらうといった課題はないが，
説明したロボットシステムの構成を大まかに理解しておいて欲しい．
ここで説明するロボットシステム構成の内容は，
移動台車に限る話ではなく，{\bf 来年度から君たちが配属すること
になる研究室で用いられる多くのロボットにおいても}，実装言語の違いこそある
ものの，共通する話となる重要な話であるので，学んでおいて損はないだろう．

今日の演習資料の目次は以下の通りである．
\begin{itemize}{\itemsep=-4pt
\item \bf {3章:サーバ・クライアント方式のロボットシステム}
\item \bf {4章:実ロボットと透過なシミュレータ環境}
\item \bf {5章:ロボットを動かす基本プログラムの使い方}
\item \bf {6章:本日の演習課題}
%%\item \bf {7章:発展課題(来週に向けて)}
}\end{itemize}
3,4章にはシステムの内容，意味についての説明が記述されている．
難しいことは何も書いていないので，5章に入る前に
さらっと読んでみて欲しい．
なお，5章が実際に本日の演習で皆に体感してもらうプログラムの構成及び内容が
チェックポイントと供に書いてあるので各自進めてみよう．
チェックポイントに書いてあることができない場合，来週以降の演習遂行
が困難になるので，うまくいかなければTAを呼ぶなりして解決して欲しい．
6章では本日の課題を載せてあるので終了したものはTAを呼んで
チェックを受けること．
時間の余ったものは，アドバンスド課題にも是非チャレンジしてみて欲しい．
%%
%%
\section{サーバ・クライアント方式のロボットシステム}
\seclabel{server-client}
数日前に行ったロボット制御プログラムでは，移動台車の反応行動プログラミングは，
後述する\subsecref{standalone}のような，
移動台車のshlinux上で完結する自律稼動プログラムで構成されていた(\figref{standalone})．
こうした方式をスタンドアローンなシステムと呼ぶ．
しかし，移動台車に乗っているCPUであるsh4の演算力は非常に低いため，
あまり高度な処理ができない（時間がかかる）ということと，sh4側で動くプログラムを開発
する際に，内部情報を覗くことが難しく\footnote{
例えば，画像処理をsh側でやろうとした場合，画像処理結果の画面を出力することがshには
ディスプレイがないためにできない．xを飛ばすにしても遅い．
}，デバッグが困難だったという問題点があった．
わざわざクロスコンパイル\footnote{
クロスコンパイラとは，
「開発に使用しているのと異なる機種で実行可能な機械語を生成するコンパイラ」
のことである．皆のThinkpadノートには，x86系のintelCPUが積んである
ため，ただのgccを使ってC言語をコンパイルしてできた機械語を，台車のCPUであるsh4上
で実行しようとしてもエラーが出る．そこで，intelCPU上でsh4用の機械語を作ってやる仕組み
が必要になるのだが，それがクロスコンパイラ，ということになる．
}
を行う必要があったのも，sh4が非力であったからに他ならない．

このような問題点を解決する乱暴な方法として，ロボットに積んであるCPUをノートPC
のように速くしてしまう\footnote{
HRP2やPR2といった比較的高級なロボットには，
デスクトップPCやサーバワークステーションクラスのCPUが積んである．}，という手法も勿論ある．しかし実際には
価格の問題であったり，消費電力の問題があり，sh4のような組込み用CPUが実際の
ロボット搭載CPUに用いられることは多いし，避けられないことがある．

そこで，考えられたのが，{\bf 搭載PCでは必要最小限の処理だけを行い，
外部PCと何らかの通信系で情報を受け渡しして，高度な演算処理は外部で行うように
してしまえば良い}，という考えである．
スタンドアローンと対比して，{\bf サーバ・クライアントな方式}と呼ばれる．
本ロボット行動プログラミング演習の大きな目的の一つが，こうしたロボットを始めとする
センサ情報処理システムで用いられるサーバクライアントなシステム
を体感してもらう，ということにある．
なお，こうしたサーバクライアントモデルは，WEBの世界では当たり前である．
Googleのgmailや，MicrosoftのAzureなどのクラウドアプリや，
AmazonのKindleFireのように非力なプロセッサで高解像度のコンテンツが見れたり
webが見れるのも，サーバクライアントのおかげである，
また高度な知的処理が必要なヒューマノイド研究でも，採用されていることが多い．
私の大好きな腱駆動ロボットも，岡田先生の大好きなHRP2やPR2も，
今現在の多くのロボット研究者たちのロボット(\figref{remote-brains}
\footnote{左からKotaro,Kojiro,Macket,HRP2,PR2,NAO,Justin,HARSY,DLR-Biped,LoLa,ECCE,iCub})が
開発段階では少なくとも何らかのサーバ・クライアントシステム
を採用しているといってよいので，是非システムの大枠を理解しよう．
EusLispが全く意味不明でも構わないので，ロボットのシステムがどうなってたかな，
くらいはこの演習で掴んでくれると切に望む．

本演習で用いる移動台車におけるサーバクライアントなシステムをより具体的に説明すると，
{\bf 移動台車のモータを動かしたり，センサデータを取得するといった
ロボットを動かす上で最低限必要な制御プログラムを台車sh側（サーバ）に用意してやり，
具体的にどのようなセンサ状態のときに，どのようなモータ指令をすればよいか，
といった高度な行動プログラムは，より演算力の高いノートＰＣ側（クライアント）で
処理する}という制御モデル(\figref{server-client})，の二つから構成されている
\footnote{
  ただし，今年度からネットワークを有線から無線に変更しているので図中における物理的な
  LANケーブルは実際には存在しないことに注意．
}．
\begin{figure}[!htbp]
  \begin{tabular}{cc}
   \begin{minipage}{0.45\hsize}
    \begin{center}
     \includegraphics[scale=0.35]{./fig/standalone.eps}
     \caption{スタンドアローンモデル：制御ループが台車SHlinux上に構築される}
     \label{fig:standalone}
    \end{center}
   \end{minipage}
   %%
   \begin{minipage}{0.45\hsize}
    \begin{center}
     \includegraphics[scale=0.35]{./fig/server-client.eps}
     \caption{サーバクライアントモデル：制御ループはノートＰＣ側，台車SHlinuxではセンサ取得とモータ制御のみ}
     \label{fig:server-client}
    \end{center}
   \end{minipage}
  \end{tabular}
  \vspace{-8mm}
\end{figure}
%%
\begin{figure}[!th]
  \begin{center}
    \includegraphics[scale=0.3]{./fig/remote-brains2.jpg}
  \vspace{-5mm}
    \caption{サーバクライアント方式のロボット例(いくつのロボットを知っているだろうか.)
    }
    \label{fig:remote-brains}
  \end{center}
  \vspace{-8mm}
\end{figure}
勿論，サーバクライアントのままでは，いつまでも外部ＰＣとのネットワークが必要なため，
最終的には，内部のCPU上でスタンドアローンで稼動する行動プログラムが実現できるのが
理想ではあるが，ロボットという小型な身体制約の上で稼動できるCPUの処理能力には限界が
あるため，多くの場合はサーバクライアントが採用されている，というわけである\footnote{
  漫画版パトレイバーの最後に登場するAVR-0はレイバーの稼動のために，外部に
  強力な演算器を積んだトラックが必要だったが，そのトラックを制圧されて，稼動不能
  になるという下りがある．まさにサーバクライアントの欠点なわけだ．
}．
%%
%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{実ロボットと透過なシミュレータ環境の重要性}
実世界上で動くロボット
\footnote{
特に皆が使うことになる移動台車は，動かしているうちに
ケーブルが断線してバンパセンサが読めなくなったり，
車輪やアームが動かなくなったりすることが，残念ながら例年頻発している．
毎年は，11月に行った稲葉研，國吉研，下山研，土肥研合同で
移動台車を修理していて演習開始時では比較的良好な状態を保つように
努力もしているが完璧ではない，また演習開始後に誤ったプログラムを実行してしまって
壊してしまうことも多々ある．気をつけよう．
}
のハードウェアは必ずしも万全の状態であるとは限らない．
例えば，どこかのセンサが故障していて外界情報が
取得できないこともあるし，
どこかのモータが故障して，腕が動かなかったり
あるいは暴走して壁に突っ込んでいくことも多々ある．

しかし，一方でロボットを動かす行動ソフトウェア\footnote{
  例えば，どういうセンサ情報をもらったときに，どのようにアクチュエータを動かすか，
  といった行動生成アルゴリズムなど，主に演習で皆が構築していく部分は
  このソフトウェア部分になる．
}
もまた，必ずしも万全とはいえない．
例えば，プログラム上のゲインの符号を誤って逆にしたために制御が発振して
暴走し，プログラマの想定外の動きをすることはよくある．
このようなプログラムをいきなり実世界のロボットに対して実行してしまうと，
最悪，ロボットが故障してしまうこともあるわけである．

このように，いきなり実世界のロボットで行動生成プログラムを開発していくと，
{\bf ハードウェアが悪いせいで動かないのか，ソフトウェアが悪いせいで動かないのか}，
という問題の切り分けができないので開発効率が悪い．ソフトウェアのせいで暴走して
故障してしまったら，修理する時間も必要になってしまう．

そこで，こうしたハードウェアとソフトウェアを切り分けて開発効率を上げるために，
シミュレーション環境を用意して，自分で作成した行動ソフトウェアを，
まずシミュレーション上で実行してバグを修正し，その上で実機で実行していく，
というプロセスが重要になってくる．
このとき，シミュレーション環境上のロボットと実世界のロボット\figref{robotmodels}
が{\bf 同一のインタフェース}で実装されていれば，用意した行動ソフトウェア
を修正することなくどちらにも使うことができるので非常に開発効率が向上するわけである．
\begin{figure}[!th]
  \begin{center}
    \includegraphics[scale=0.45]{./fig/robotmodels2.jpg}
    \vspace{-5mm}
    \caption{実世界とシミュレーション上のロボット例}
    \label{fig:robotmodels}
  \end{center}
    \vspace{-7mm}
\end{figure}

岡田先生のソフトウェア第三でも教わることになる移動台車モデルは，
Euslisp上のシミュレーション環境で動くロボットだが，
実機に送るインタフェースと同様のインタフェースで，実際に腕を動かしたりセンサ情報を読んできたり
することができる\footnote{
実際には，まだ開発中で未実装な部分は多々あって，今後増えていく予定．
}．
つまり，岡田先生のソフトウェア第三でEuslispシミュレーション環境上での移動台車の動かし方に慣れて
おけば，{\bf 本日以降のロボット行動プログラミング演習で使うプログラムは，基本はほとんど同じなので，
慣れないプログラムに戸惑うことが少なくなり，演習が早く終わる}はず，である．
もし君が比較的慣れている人ならば，情けは人のためならず，の精神で，
良くわかっていない周囲の人に教えてあげよう．
\clearpage
%%
%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{ロボットを動かす基本プログラムの使い方}
\subsection{演習の実行環境について(全5回共通)}
ロボット行動プログラミング演習では，\figref{setting-image}のように，
{\bf 皆のThinkpadのノートPCでLinux(Ubuntu)を立ち上げてもらい，
その上でロボットを動かしていく}．これはロボット制御演習と同様である．
{\bf 班分け，用いる台車の番号(シール)及び固定IP，各ノートPCの固定IPの設定については，
前回のロボット制御で決めたものをロボット行動プログラミングでも引き続き使っていく}．
IPが衝突すると自分だけでなく同じネットワークにいる他の人にも影響が出るので勝手に新たな固定IP
を振らないようにすること．
%%
\begin{figure}[!th]
  \begin{center}
    \pastefig{fig/setting-image.eps}{width=.5\hsize}
    \caption{演習環境のセットアップイメージ（台車，ノートＰＣ，をネットワーク(今年度より無線)
        を介して接続)}
    \figlabel{setting-image}
    \vspace{-5mm}
  \end{center}
\end{figure}
%%
\begin{figure}[!th]
  \begin{center}
    \pastefig{fig/enshu-system2.eps}{width=1.1\hsize}
    \caption{演習のシステム全体概要図}
    \figlabel{enshu-system}
    \vspace{-5mm}
  \end{center}
\end{figure}

\figref{enshu-system}が，これから君たちが使っていくことになる移動台車のシステム概要図
である．shlinux(移動台車)とlinux(ノートPC)にソフトウェアが分散して配置されているのが
わかると思う．色付きの四角で囲んである箇所が実行プロセス\footnote{
  C言語で実装されているものは，ファイル名がそのまま実行プロセス名として記述してある．
  EusLispで実装されている部分は，()で囲まれた実行関数を実行プロセス名として記述し，
  実行関数を記述しているファイル名を記載してある．
}を示しており，黄色は台車shlinux側での実行プロセスを，水色はノートlinux側での実行プロセス
を表している．角の丸い四角はこれらの実行プロセスを記述しているファイルディレクトリを
示している．また，何らかのデータの受け渡しについて赤線で記述している．
なお，色が見にくい場合は，資料PDFを用意したので，それを見て貰いたい．

{\footnotesize{
\begin{verbatim}
wget --user=lecture --password=jsk-lecture http://www.jsk.t.u-tokyo.ac.jp/nakanish/enshu/robot-programming-1.pdf
\end{verbatim}
}}

演習で使うソフトウェアについて簡単に説明しておこう．
\figref{enshu-system}の右側のノートPC上Linuxの大枠にあるように，
演習で使うソフトウェアは，
{\bf jskeus}と{\bf jsk-enshu/robot-programming}の二つのディレクトリに収められている．

まず{\bf jskeusはEusLispのインタプリタや基礎的な関数ライブラリのためのディレクトリ}であり，
EusLispを実行するために必要なディレクトリと思ってくれて構わない．
詳細については岡田先生のソフトウェア第三にて触れているはずなので，ここでは説明を省略する．

一方，{\bf jsk-enshuは本演習で用いるロボットを動かすためのShlinux側ソフトウェア
及びThinkpad側ソフトウェアといったサーバ・クライアントシステムや，
EusLispで記述されたシミュレータ環境といった演習に必要なプログラム}から構成されている．
実際にjsk-enshu/robot-programmingをlsして内容を見てみると，以下のディレクトリがあるはずである．
\figref{enshu-system}内にも各ディレクトリの簡単な説明を加えているが，もう少し詳細に
説明すると，それぞれのディレクトリ分けには以下の意味がある．こうした意味を頭に入れておくと，
プログラムを構築する際に自分が欲しいプログラムがどこにあるかをある程度類推できる
ようになるはずである．

{\footnotesize{
\begin{screen}
 \vspace{-2mm}
  \begin{verbatim}
 jsk-enshu/robot-programming
  |-- Makefile 
  |     環境全体のcompile，必要ファイルの台車shへのコピー
  |-- driver
  |     shlinuxでpc104経由でfpga周りのデバイスを制御するためのデバイスドライバ
  |-- common
  |     以下のstandalone, server, clientで使うライブラリやインクルードファイル
  |     socket通信，台車制御，サーボ制御，サーバクライアントプロトコル，等がある
  |-- standalone
  |     台車側のみで自律稼動するプログラム．
  |     ロボット制御の演習で使っているのはここ．
  |-- server
  |     台車側で動くサーバプログラム
  |-- client
  |     台車側のサーバプログラムに対して，命令を送るThinkpadのノートＰＣ側で動く
  |     クライアントプログラム．本演習では，行動制御プログラムは主に，この
  |　　 クライアント側で構築していく
  |-- eus
  |     移動台車のEusLispで記述されたシミュレータ環境．
  |     ソフトウェア第三で使っているのはここ．
  |-- python
         pythonを使ってサーバにコマンドを送るプログラム．演習では使わないが，
         どうしてもEuslispを使うのが難しい人は自己責任で挑戦してみよう
  \end{verbatim}
 \vspace{-10mm}
\end{screen}
}}

さて，\figref{enshu-system}にあるほぼ全ての実行プロセス(色つき四角枠)を
実際に実行してもらい，{\bf ロボットのアーム，台車を動かす，センサ情報を取得する，シミュレータを起動する}
にはどうすればいいのかを体感しながら，全体像をつかんで貰うのが今日の
目的である．複雑に見えるかもしれないが，本章のチェックポイントを着実にこなせば
実行できるはずである．
ただし，\secref{kadai}の課題1はTAが君たちのシステム概要理解度を確認するという
内容であるため，漫然とチェックポイントをこなすのではなく，
{\bf 各チェックポイントで実行した作業が，\figref{enshu-system}の
どの部分であるかを強く意識しながら進めていくと良いだろう}．

早速，まずチェックポイントを復習を兼ねてこなしてみよう．
開発環境の準備として，
各班一人はUSBシリアルを用いて，台車のshlinuxに対してシリアルコンソールを開いておき
(ubuntuではminicomを用いて通信)，初期の起動(bを押す)を行い，また別途ネットワーク
を介してsshで{\bf user=root，pass=shlinux}でログインしてみよう．
ロボット制御の演習で行ったはずであるが，
やり方を忘れてしまった場合は，TAを呼ぶか，仲間に聞くか，やり方を思い出して欲しい．
\begin{itembox}[|]{{\bf チェックポイント1: Shlinuxへのログイン}}
 \$ ssh root@192.168.x.y\\
 と打って台車にきちんとネットワーク経由で各班３人ともログインできるか.
\end{itembox}
{\bf この作業を\figref{enshu-system}上では，
図の真ん中上くらいにある，ノートPC上Linuxでminicomやsshの四角枠で囲まれたプロセス
を実行することで，赤色の各経路経由で台車にログインした，という風に表現されている}．
以下続々と続くチェックポイントをこなす場合も，面倒かもしれないが
同様に逐次に図のどの部分を実行したかを確認しながら進めて見て欲しい．
単純に実行していくだけで全く分からないで終わるよりも，少しでも各ソフトウェアの関係を
把握してみて，将来何らかのシステムを組む場合に，あのとき似たようなことをやったな，
くらいを思い出せてもらえるようになってもらいたい．
%%
\subsection{実験環境構築に必要なソフトウェアの取得・更新}
本演習で用いるjskeus，jsk-enshuは，Sourceforgeに上がっている．
君たちの多くは既にjskeusは岡田先生のソフトウェア第三で，
jsk-enshuはロボット制御演習でsvnでcheckout(取得)済みのはずであるので，
{\bf 新規に取得する必要はない}が，復習のために新規に取得する場合の手順を以下に示す．
\begin{screen}
\begin{itemize}
\item {\bf jskeus: EusLispの実行環境}\\
  \$ cd \~/prog\\
  \$ svn co http://jskeus.svn.sourceforge.net/svnroot/jskeus/trunk jskeus\\
  \$ cd \~/prog/jskeus\\
  \$ make\\
  更新があった場合，{\bf makeと打ってcompileしないと反映されない}ことに注意！
\item {\bf jsk-enshu: 演習に関するソースディレクトリ(詳細は後述)}\\
  \$ cd \{自分でチェックアウトしたい場所 prog以外でも構わない\}\\
  \$ svn co http://jsk-enshu.svn.sourceforge.net/svnroot/jsk-enshu/trunk jsk-enshu\\
  \$ cd jsk-enshu/robot-programming\\
  \$ make\\
  初めてチェックアウトした場合はcommon/Makefile.genのDAISYA\_IPを自分の台車の固定IPにセットする必要がある．
\end{itemize}
\end{screen}

ただし，機能が追加されたりバグが修正されている場合には，
こちらでupdateして欲しいと通知するので，その場合はupdateして環境を更新できるように
しておいて欲しい．
そこで{\bf まずは環境の更新の仕方をおさらい}してみよう．
なおsvn updateした際にCが出る場合は，更新が失敗している場合であるので，
自分で変更点をマージする必要がある．対処がよくわからない人はTAを呼んで解決してもらおう．
適当に放っておくと，後で色々動かなくなってこまることになる．
\begin{itembox}[|]{{\bf チェックポイント2: 演習環境の更新}}
\begin{itemize}
\item {\bf jskeus: EusLispの実行環境}\\
  \$ cd \~/prog/jskeus\\
  \$ svn update\\
  \$ make\\
  更新があった場合，{\bf makeと打ってcompileしないと反映されない}ことに注意！
\item {\bf jsk-enshu: 演習に関するソースディレクトリ}\\
  \$ cd jsk-enshu/robot-programming\\
  \$ svn update\\
  \$ make
\item {\bf svnに上がっているソースと自分の書いたプログラムソースの状況確認}\\
  \$ cd \{差分が知りたいディレクトリへ\}\\
  \$ svn status
\item {\bf svnに上がっているソースと自分の書いたプログラムソースの差分確認}\\
  \$ cd \{差分が知りたいファイルのあるディレクトリへ\}\\
  \$ svn diff \{ファイル名\}
\end{itemize}
\end{itembox}
{\bf この作業は全体システムの中では\figref{enshu-system-c2}の赤色部分}に相当する．従って，当然Thinkpadの
Linux上で実施されるべき作業であり，sshやminicomでログインしたshlinux上で行っても
駄目である．まずはshlinxuとlinuxの二つの実行環境を自分は行き来しながらロボット行動
開発を行っているのだ\footnote{
で，チェックポイント2の作業はthinkpad側である!}，ということを改めて意識しておこう．
\begin{figure}[!th]
  \begin{center}
    \pastefig{fig/enshu-system-c2.jpg}{width=0.8\hsize}
    \caption{演習のシステム全体概要図におけるチェックポイント２該当箇所}
    \figlabel{enshu-system-c2}
    \vspace{-5mm}
  \end{center}
\end{figure}

この意味が分からない人や，更新後システムが壊れてmakeが通らなくなった人は，
今後困るので，復帰方法も含めてTAにやり方を聞いて更新作業が出来るようにしておこう．
なお，この作業には無線ネットワークに繋がっている必要がある\footnote{
  このときに繋げる無線ネットワークはjohorikoでないと繋がらない．
  台車と繋ぐ際の無線ネットワークとは違うことに注意しよう．
}
ので，無線ネットワークで外部に繋がらない人は残念ながらできない．
その場合TAを呼んでとりあえず最新のソースコードを保存したUSBメモリを渡してもらい，
環境を最新にしておくこと．
%% このとき，前回のロボット制御の演習において，車輪のPゲイン調整を行った場合は
%% 申し出ること．そのファイルのみ自分のものを使うようにしなければ
%%
%%
%%
%%
\subsection{クロスコンパイラの更新}
shlinux側の実行ファイルをノートＰＣで作成するためにはクロスコンパイラ
(本演習ではsh4-linux-gccを使っている)が必要であり，前回のロボット制御プログラミング
の演習においても，既に皆使っていたはずである．
しかし，今回からshlinux上でOpenCVライブラリを利用した画像処理プログラミングを
行う予定であり，そのためには今まで皆が使っていたクロスコンパイラでは，gccのバージョン
が古いためにうまく演習が行えない．

そこで，クロスコンパイラのバージョンを新しく4.1に変えてもらう必要があるので，
そのための作業を演習を本格的に始める前にやってもらいたい．
手順は以下である．
\begin{itembox}[|]{{\bf チェックポイント2-1: クロスコンパイラの更新}}
\begin{itemize}
\item {\bf 新しいクロスコンパイラの更新データの取得(ネットワーク経由)}\\
  \$ cd \~/prog/jsk-enshu/robot-programming\\
　一度に以下を実行するとサーバがパンクするので，{\bf 班で一人ずつ順番に}行うこと

{\footnotesize{
\vspace{-5mm}
\begin{verbatim}
$ wget --user=lecture --password=jsk-lecture http://www.jsk.t.u-tokyo.ac.jp/~nakanish/enshu/archive.tar.gz
\end{verbatim}
\vspace{-5mm}
}}

\item {\bf 新しいクロスコンパイラの更新データの取得(USBメモリ経由)}\\
  上述したネットワーク経由でのダウンロードが遅すぎる場合はUSBメモリを用意したので，そこから
　データを持ってきて欲しい({\bf ネットワーク経由で既に取得できた人はここはやる必要はない})\\
  \$ cd \~/prog/jsk-enshu/robot-programming\\
  USBメモリ内にあるarchive.tar.gzを上記の場所に置く
\item {\bf クロスコンパイラの更新}\\
  \$ cd \~/prog/jsk-enshu/robot-programming\\
  \$ tar xvzf archive.tar.gz\\
  \$ cd archive\\
  \$ sh update.sh\\
   途中でrootパスワードが聞かれるかもしれない．その場合は，自分のt400sのUbuntuでの
   sudo時に聞かれるパスワードを入力しよう．\\
   また，{\bf archive PATH wrong!!} のようなエラーが出てきて終了してしまう人は，
   archive.tar.gzを展開する場所が間違っているので，
   \~/prog/jsk-enshu/robot-programming以下に展開したかをもう一度確認してみよう．
\item {\bf クロスコンパイラの更新確認}\\
  \$ sh4-linux-gcc -v\\
  と打ってみて，最後にgcc version 4.1.0と出てくればうまく更新されているはずである．
\end{itemize}
\vspace{-5mm}
\end{itembox}

\subsection{ソフトウェア環境全体のコンパイル及びshlinuxへの実行ファイル一括コピー}
jsk-enshu/robot-programmingの各ディレクトリの概要を前述したが，これらの各ディレクトリ
で用いる全てのプログラムのコンパイルと，shlinux(移動台車)上で実行すべきファイルの
コピーを一括で行うことが可能である．
既にロボット制御において行っているはずであるが，svnの更新，クロスコンパイラの更新，
がうまくいっていれば，エラーなく全て最後まで通るはずである．試してみよう．
手順は以下である．
%\begin{screen}
\begin{itembox}[|]{{\bf チェックポイント2-2: 環境更新の確認}}
  \$ cd \~/prog/jsk-enshu/robot-programming  (別場所でcheckoutした場合は読み替えること)\\
  \$ make clean\\
  \$ make          (全てのファイルの一括コンパイル)\\
　　　このmakeは，ノートPC上で，移動台車を動かすためのプログラムを全てコンパイル\\
　　　する作業を呼び出している．このとき，standaloneやserverのプログラムは，sh4用\\
　　　のクロスコンパイラを使ってコンパイルし，clientのプログラムは，x86用のコンパ\\
　　　イラを使ってコンパイルしている．\\
  エラーが出る人は演習が最後までうまく出来なくなってしまうので，この段階でTAを呼んでみよう．
　クロスコンパイラが更新できていない，
　あるいは，robot-programming以下の環境が最新でない，PC上にインストールされている
  opencvのバージョンがゼミ等の関係で新しすぎる\footnote{
    本演習においては，opencvのバージョンは2.0.0を仮定している．
    バージョンは pkg-config opencv --cflagsで返ってくるディレクトリにあるcvver.hを見てみれば，
    確認できる．
  }，などの原因が考えられる．
  \$ make allcopy (全てのshlinux実行ファイルのcopy)
%\end{screen}
\end{itembox}
なお，ソース一式を初めてsvn checkoutした場合は，common/Makefile.gen内のDAISYA\_IPを
自分の台車の固定IPにセットしてから上記を実行する必要がある．
%%
%%
%%
\subsection{各ディレクトリの説明：standalone}
\subseclabel{standalone}
このディレクトリの下にあるプログラムは，{\bf 移動台車のshlinux上のみで独立して実行可能な
もの}である．ロボット行動プログラミングでは，\secref{server-client}において紹介したサーバクライアン
トモデルを使うので，{\bf こうしたスタンドアローンなプログラムは使わない}が，
ロボット制御の演習では，このディレクトリで作業したことを覚えているだろうか．
そのときに実行したプログラムは同じように動くはずである．

ただしロボット行動プログラミングにおいても，{\bf サーボ(腕)が思ったように動かない場合や故障した場合等，
ロボット制御で行ったservo\_testを実行し，再びサーボの設定ファイルをつくりなおしてもらう}
必要があるので，やり方を忘れた人はロボット制御の資料を見て欲しい．
簡単に使い方を復習しておくと，
\begin{screen}
  \$ cd \~/prog/jsk-enshu/robot-programming/standalone/arm, wheels, sensors\\
  \$ make　　　　　(shlinux上で動く実行ファイルのクロスコンパイル)\\
  \$ make copy　　　(shlinux実行ファイルのcopy)\\
　　　台車にログインしたターミナル上で\\
  \# cd \~/bin\\
  \# ./servo\_test  (例えばservo\_testを実行する場合)
\end{screen}
\begin{figure}[!th]
  \begin{center}
    \pastefig{fig/enshu-system-n1.jpg}{width=0.8\hsize}
    \caption{演習のシステム全体概要図におけるロボット制御での実施該当箇所}
    \figlabel{enshu-system-n1}
    \vspace{-5mm}
  \end{center}
\end{figure}
なお，{\bf この作業はシステム概要図では\figref{enshu-system-n1}の部分に該当している}ことが，
現時点で分かっていれば，ロボット制御の演習の目標は8割ほど達成されているので桑名先生や
大村先生も喜ぶだろう．コマンドライン上では数行の実行しかしていない作業でも，実はシステム図
での動きを見るとそれぞれの実行にこれだけの意味があったことが改めて分かってもらえると思う．
%%
%%
%%
\subsection{各ディレクトリの説明：server}
\subseclabel{server}
さて，ここからがロボット行動プログラミングの本題である．
ロボット行動プログラミングでは，サーバクラインアントモデルでシステムを構築していく
と最初に説明したが，まず{\bf 移動台車側での最低限必要な制御用プログラム（サーバプログラム）の
構築及び起動方法}について説明しよう．

サーバ・クライアント方式のシステムの実装方法には色々考えられるが，本演習では，
{\bf 台車shlinux，ノートPC上linuxのようにTCP/IPネットワークで結ばれた
二つのOS上でのプロセス間のデータ通信をする上で，よく用いられるソケット通信を
利用してサーバ・クライアントを実装}している．
サーバサイドのプログラムは，serverディレクトリに以下の2つが用意されている．
\begin{itemize}{\itemsep=-4pt
\item {\bf ロボットサーバ}\\
 server/robot-serverの下にある．\\
 クライアント側からの命令を受けると，腕servoを動かしたり，台車wheelを動かしたり，
 bumperやpsdセンサの状態を取得して，その情報をクライアントに送り返す処理を行う．
\item {\bf ビジョンサーバ}\\
 server/vision-serverの下にある．\\
 クライアント側からの命令を受けると，台車のshボードのUSBポートに接続したUSBカメラ
 の生データや，処理結果をクライアントに送り返す処理を行う．
}\end{itemize}
いずれの場合も，C言語により実装されている．これらC言語でのソケット通信周りの
実装については，夏学期演習でやったことを用いている\footnote{
socket()，bind()，listen()，accept()といった関数を用いて実装したはずである．
}．少し工夫した点としては，複数のクライアントが接続できるようなマルチクライアント
機能を持たせている点だろうか．サーバはクライアントからの待ちうけを行っており，
接続された場合には通信用のthreadを新たに立ち上げることで実装を行っている．
詳しく知りたい人は，{\bf robot-programming/common/lib/multi\_socket\_functions.c}
に関数が記述されており，各サーバはその関数を呼び出すことで機能を実現しているので
見てみて欲しい．

なお，{\bf USBカメラを用いた画像サーバについては次回説明を行う}ので，ここでは
ロボットサーバについて詳しく説明を行う．
%%
\subsubsection{ロボットサーバ}
ロボットサーバプログラムは，shlinux上で動くため，
ノートＰＣのUbuntu上でクロスコンパイルし，実行ファイルを台車shlinuxにscpを
用いてコピー，そしてsh側で起動，という手順を取る．クライアントと通信を行う点以外は，
ロボット制御で取り組んでもらったstandaloneのプログラムと同様である．
さて，実際にやってみよう．ノートPC(Ubuntu)側で，
\begin{itembox}[|]{{\bf チェックポイント3: serverの起動}}
 \vspace{-2mm}
  \begin{verbatim}
    $ cd ~/prog/jsk-enshu/robot-programming/server/robot-server
    $ make
     クロスコンパイルする．なお，~/prog/jsk-enshu/robot-programmingの下でmake
　　 としておくと全てのディレクトリが自動でmakeされるため，その作業をやった場合は，
　　 ここでは何も起きないかもしれない．
　　 ただし，自分でサーバプログラム（robot-server.c)を修正した場合には，makeして
     再クロスコンパイルする必要があることに注意せよ．
　  $ make copy
     実行ファイルを台車shlinuxにコピーする．~/bin以下にコピーされる．
     これについても，上と同様，改めて再コンパイルした場合は必ずmake copyする
    $ ssh root@192.168.x.y
      台車にログイン(以降は，台車端末上)
    # cd ~/bin
    # ./robot-server
    で起動完了である．なお，サーボの設定ファイル
    servoparamが必要なため，binの下にservoparamがない場合は，ロボット制御で
　　行ったことを思い出しservo_testを実行してservoparamファイルを作成せよ．
  \end{verbatim}
\vspace{-10mm}
\end{itembox}
のようにすればよい\footnote{
  ちなみに，makeの中身で何をしているのか良くわからない場合は，
  make -n copy
  のように，-nオプションを付けて実行してみよう．こうすると，実際に実行されるコマンド
  を実行せずに確認することができるので便利である．
}．
{\bf shlinux上で，./robot-serverとして放置しておけば，ずっとクライアントからの接続が来るまで
サーバプログラムは待ち続ける}ことになる．
従って，この段階（クライアントがいない段階）では，目に見えて台車が動くことはなく，
何も変わることはない．

なお，{\bf サーバプログラムは各班で一つしか立ち上げられない}\footnote{
 robot-server，vision-serverがそれぞれ一つしか立ち上げられないという意味であり，
 robot-serverとvision-serverは同時に立ち上げることができる．
 なお，vision-serverは次回行うUSB画像処理を行うサーバプログラムである．
}ことに注意せよ．
皆が試したい場合は，必ず立ち上げた人が一度サーバプログラムを，Enter(あるいはCtrl-C)
を押して終了してから試すこと．これはロボット制御で行ったstandaloneなプログラムサンプルと同様である．

{\bf このチェックポイント作業はシステム全体図において，\figref{enshu-system-c3}}のようになる．
ほぼロボット制御で行ったstandaloneなプログラムの起動作業とやっていることは同じである．
違いは，serverプログラムはクライアントからの接続を待つために，socketを監視しているという点(青丸)
だろうか．
\begin{figure}[!th]
  \begin{center}
    \pastefig{fig/enshu-system-c3.jpg}{width=0.7\hsize}
    \caption{演習のシステム全体概要図におけるserver起動該当箇所}
    \figlabel{enshu-system-c3}
    \vspace{-5mm}
  \end{center}
\end{figure}

ロボットサーバプログラム(robot-server.c)の中身について，簡単に説明しておこう．
演習で直接ロボットサーバプログラムを触ることはないとは思うが，何を行っている
部分かは理解しておいて欲しい．興味があればC言語で記述されているので，ソースを
見てもらうとより理解が深まると思う．
\begin{itemize}{\itemsep=-4pt
\item {\bf クライアントとの通信}\\
  前述した通りように，クライアントからのsocket待ちうけスレッドを起動し，
  常にクライアントとの接続を待ち受けている．
  クライアントから接続されると，クライアントとのやりとりをする
  新たなスレッド(reader)を立ち上げ，クライアントからの指令を解釈する．
  {\bf デフォルトではport 5000番にてsocket待ちうけ}を行っている．
\item {\bf クライアントからの命令（コマンド）解釈}\\
  解釈を行う部分が，robot-server.cの中のinterpreter関数である．
  予め決められた{\bf サーバークライアントのやりとり（プロトコル）は，
  robot-programming/common/lib/command.cに記述されており}，例えば，clientから
  "servo-angle-vector"という文字列が送られてくると，サーボ目標角度を格納している
  servosというメモリ領域の中の，\verb+goal_angle+を修正する，という具合になっている．
\item {\bf 台車の制御}\\
  移動台車を制御するためのスレッド（サーボ制御スレッド，
    車輪制御台車スレッド）を起動時に立ち上げることで，上述したような制御用メモリ領域
  (servosやwheels）の値に応じて，移動台車を制御している．
  これらの基礎的な制御部分については，
  robot-programming/common/lib/wheels.cやservo.cに記述されており，
  これはstandaloneでも使われている共通のライブラリ関数となっている．
  前回のロボット制御で皆が一生懸命台車がまっすぐ動くようにwheels.c内のゲインを
  調整していたと思うが，このときの成果が生きてくるはずである．
  ただし，{\bf 前回の演習でゲインを調整したファイルを持っている人がrobot-serverを作成し，
    shlinux側にコピーしないと意味がないことに留意せよ．}
\item {\bf センサ情報の取得}\\
  スレッドではなく，robot-serverのmainループで毎回bumperとpsdのデータを更新し，
  センサ情報を格納するメモリ領域に常に最新の値を更新して入れている．
  クライアントから，センサ情報を取得するコマンド(get-robotstate)が来ると，該当する
  データを文字列でクライアントに送り返す．（この処理は，interpreter関数に記述している)
}\end{itemize}
%%
%%
\subsection{各ディレクトリの説明：client}
\subseclabel{client}
さて，ここからは\subsecref{server}で説明したサーバプログラム(robot-server)が台車上で起動
していることを前提に話を進める．
なお，サーバプログラムと違い，クライアントプログラムは何個でも（現実的には一人一個くらい）
は立ち上げられる実装になっているので，ここからは{\bf 各班の人が同時にクライアントプログラム
を起動してもらって構わない．ただし，ロボットの同じ箇所を動かす指令を送るプログラムを
実行する場合は，同時には命令を送らない}こと\footnote{
  例えば，二人同時に，同じサーボジョイントに対して，間逆のコマンド指令を送る，などは
  してはいけない．壊れてしまう可能性がある．
}．

クライアントプログラムはノートPCのUbuntu上で動くものであり，
台車のサーバから情報を貰ったり，逆に制御コマンドをサーバに送って
台車を動かす行動プログラムが記述されることになる．
通信は各クライアントプログラム全て{\bf ソケット通信}による実装がなされている．

サーバクライアント方式にすることで，ロボット制御のようなスタンドアローン方式な開発と異なり，
\begin{screen}
\begin{itemize}
\item クライアント側のソフトウェアをshlinux側にscpでコピーする必要がない．
\item 台車を共有していても，ロボット動作プログラムは個々人のノートPCで実行できる．
\item ノートPCの高速なPC環境が使える．Xwindowシステムで窓を立ち上げたりも可能
\end{itemize}
\end{screen}
という恩恵が受けられることを，今日は覚えて帰って欲しい．
clientの下に，以下の3つのディレクトリが用意されている．
\begin{itemize}{\itemsep=-4pt
\item {\bf robot-viewer}\\
  ロボットのセンサを含む内部状態を見るためのプログラム．
  あまり使わないが，デバッグ用途に使う．ここではC言語でクライアントを
  記述した場合の例として実装を行っている．
\item {\bf eus-client}\\
  ソフトウェア第３の講義は全てはこのためにあった(笑)．
  Lisp系言語の一つであるEusLispを使ってロボットを動かすための
  クライアントプログラムがここに記述されている．
  今後の演習は，主にこの層のプログラムを自分で書いて，ロボットを
  好きなように動かしてもらうのが主題となってくる．
\item {\bf vision-viewer}\\
  ロボットのUSBカメラデータや処理後のデータを見るためのプログラム．
  ビジョンサーバのデバッグに必須な道具となる．
}\end{itemize}
では，各クライアントプログラムの動かし方を説明していく．
また，{\bf vision-viewerについては次回以降使い方を説明する}ので，今回は説明しない．
%%
\subsubsection{robot-viewer}
サーバプログラムの一つである{\bf robot-server}とやりとりして，現在のロボットのセンサ状態を
取得するクライアントプログラムである．イメージとしては，ロボット制御で行った
standaloneディレクトリにあるセンサ状態表示プログラムである
\verb+view_sensors+のクライアント版といった感じだろうか．

なお，本体はrobot-viewer.cだが，中身は非常に簡単で，
{\bf ソケットでサーバと通信}し，通信できたら，{\bf センサ情報を送ってくれというコマンド
（get-robot-state)をサーバに対し送信}し，{\bf 返ってきた文字列を解釈して表示}
するだけである．
少し面倒なのは，返ってくる文字列情報が，後でeus-clientで利用しやすいように，
()でくくられるS式になっており，そのパース（構文解釈）をする必要がある点である．
これらの構文解釈関数は，robot-programming/common/lib/interpreter.cに
あるので，興味がある人は見てみて欲しい．
少し改造すれば，後述するeus-clientのような行動制御クライアントを
C言語で記述することもできるかもしれない．

プログラムは，robot-programming/client/robot-viewerの下にあり，ノートPCのUbuntu上で以下の
ようにすれば実行できるはずである．
\begin{itembox}[|]{{\bf チェックポイント4: clientの実行1}}
 \vspace{-2mm}
  \begin{verbatim}
    $ cd ~/prog/jsk-enshu/robot-programming/client/robot-viewer
    $ make
     普通のコンパイルが実行される(クロスコンパイルではない!!)

    以下，robot-serverが台車shlinuxで立ち上がっている状態で，Ubuntu上で
    $ ./robot-viewer
     とすると，robot-serverの方では，Connectedと接続された旨が表示され，
     クライアント側では，色々な情報の数値が表示されるようになると思う．
     一番したの方にあるのが，センサ情報で，
     bumper-vectorがバンパのONOFF状況で，6要素あるはず．
　　 ためしに，バンパを押してみて，押すと1に，押さないと０になることを確認せよ．
     psd-vectorは距離センサの値で３つある．
　　 他にも，上の方にwheel-goal-angleのような車輪目標値や制御モードの
　　 情報が一度に表示されている．
     次で説明する，eus-clientからロボットを動かしたときに，これらの
　　 値が動いていることを確認できれば，なおよい．
  \end{verbatim}
  %%$
 \vspace{-10mm}
\end{itembox}
うまくいくと，\figref{robot-viewer}のようになるはずである．
何度もいうが，こうしたクライアントプログラムは同時に各班全員が試せるはずである．
なので，{\bf 3人とも同時に接続できるかを確認してみて欲しい}．
\begin{figure}[!htbp]
    \begin{center}
     \includegraphics[scale=1]{./fig/robot-viewer.jpg}
     \caption{robot-viewerの様子}
     \label{fig:robot-viewer}
    \end{center}
  \vspace{-5mm}
\end{figure}
%%
\begin{figure}[!th]
  \begin{center}
    \pastefig{fig/enshu-system-c4.jpg}{width=0.8\hsize}
    \caption{演習のシステム全体概要図におけるclient起動該当箇所}
    \figlabel{enshu-system-c4}
    \vspace{-5mm}
  \end{center}
\end{figure}
{\bf このチェックポイント作業はシステム全体図において，\figref{enshu-system-c4}}のようになる．
赤色はserverの起動で既に実施されている部分，青色が新たに今回client起動によって実行された箇所
となっている．前述したserverとソケット通信を介してロボットデータを貰い，
{\bf ノートPCのLinux側の実行プロセスでロボットデータを表示}している．
ロボット制御で実施した似たようなセンサ表示プログラム(view\_sensors)は，
ssh(あるいはminicom)で台車にログインすることで，
{\bf 台車shlinux側の実行プロセスでセンサデータを表示していた}，という実行プロセスの実行場所に
大きな違いがあることを理解して欲しい．
%%
%%
%%
%%
\subsubsection{eus-client}
robot-viewerは，ロボットの状態を表示するためのビューアに過ぎず，
実際にロボットがどのように動くかという指令を送るものではないため，
行動プログラムを記述したクライアントプログラムが別途必要となる．

ここでは，実際に{\bf ロボット行動プログラムを実行できるクライアント環境を
euslisp上に用意した}ので，その使い方を説明していく．
こうした行動生成用クライアントプログラムは，勿論C言語でも記述可能だが，
あえてeuslispを採用した理由としては，
\begin{itemize}{\itemsep=-4pt
\item {\bf interpreter言語なので対話的にロボットを動かせる}\\
  ロボット行動プログラムを開発する上では，パラメタ調整など何度も変えて
  地味に動作を修正するデバッグ作業が多かったりする．
  こうした場合，プログラムを一々コンパイルする必要のない，対話的な
  プログラムによって上位の行動プログラムが記述されていると，非常に便利である．
  少し乱暴ではあるが，{\bf 「考える前に試せ」がロボットデバッグの基本の一つ}であり，
  それを簡単に体言できるのがEuslispのようなinterpreter言語であるといえる．
\item {\bf Lispの高い記述力を利用して行動プログラムを簡潔に表現可能}\\
  ロボット行動プログラムを記述する上では，岡田先生のソフトウェア第３の講義
  で習ったように，探索問題のようなAIプログラムは非常に有用だが，これらの
  プログラムを記述する上で，List処理の優れたLisp系言語は非常に強力なツール
  となる．Lispを使うことで，C言語を使うと比較的長くなってしまう表現も
  短く簡潔に表現することが可能である．
\item {\bf ロボット行動制御に関する基礎関数ライブラリが標準で用意されている}\\
  ロボットを動かしていくには，
  ロボットの幾何形状の表示ライブラリや，幾何形状回転計算ライブラリ，
  ソケット通信やファイル操作等のデバイスアクセス関数ライブラリといった
  様々なライブラリが必要となってくる．EusLispではこうしたロボットのための
  ライブラリが実行時に既に組み込まれており，関数を呼び出すだけで簡単に
  色々な機能を実現していくことができるため，ちょっとしたサンプルを記述する
  際は便利である．
}\end{itemize}
といった理由が大きい\footnote{
  逆に，欠点としてC言語に比べて実行速度が遅いといった問題もかかえているが，
  速い処理は，末端のサーボ制御側で必要になるため，そちら側をC言語で記述
  しておき，比較的時間に余裕のある上位の認識行動プログラムは，より高級な
  Lispのような言語で記述しておく，というシステムモデルが採用されることが多い．
}．
同様の理由でinterpreter言語の一つであるpythonなどをロボット研究の
最上位層に使っている人も最近増えているようである．

さて，前置きはともかく使い方を説明しよう．
ここが{\bf 今日を含めた今後のロボット行動プログラミングの肝}となるので，
少なくとも今日のうちに，使い方（ロボットのeuslispからの動かし方)に一刻も早く
慣れて欲しい．
プログラムは，robot-programming/client/eus-clientの下にある．
使い方は，Ubuntuの端末上から以下のようにやって行こう．
ただし，{\bf robot-server(\subsecref{server}) が台車上shlinuxで立ち上がっている}ことを
前提としている．

まず，EusLisp環境を立ち上げよう．
\begin{screen}
 \vspace{-2mm}
  \begin{verbatim}
    $ emacs &
    まず，emacsを立ち上げ，euslispを起動しよう．
    emacs上で，M-x shell と打ってシェルを起動する．
　　そのシェル上で，
    $ irteusgl
    と打つと，euslisp環境が立ち上がり，euslispが使えるようになる．
  \end{verbatim}
 \vspace{-10mm}
\end{screen}
%%
\begin{figure}[!th]
  \begin{center}
    \pastefig{fig/enshu-system-c5.jpg}{width=0.8\hsize}
    \caption{演習のシステム全体概要図におけるEusLispでのserverとの接続，関数実行}
    \figlabel{enshu-system-c5}
    \vspace{-5mm}
  \end{center}
\end{figure}
さて，次に立ち上げたeuslisp環境で，robot-serverと接続する
ための関数を定義したrobot-client.lファイルをロードして，サーバと接続してみよう．
{\bf まず，下準備(超重要!!)として，emacsでrobot-client.lを開き，89行目の
  (defvar *hostname* "192.168.x.y")
と書いてある部分を自分の台車のIPに修正してsaveする．}
後は，このファイルをロードすれば対話的にロボットを制御することが可能となる．
\begin{itembox}[|]{{\bf チェックポイント5: EusLispからserverへの接続}}
 \vspace{-2mm}
  \begin{verbatim}
     以下でirteusgl $ はemacs上のeusのプロンプトを示す．
   irteusgl $ (load "robot-client.l")
     これで，serverと繋ぐために必要な関数を使えるようになる．
     (connect-robot-server)
     (connect-vision-server)
     というメッセージが出てくると思う．
　　 これは，robot-client.lの中の91行目，92行目を見ると分かるが，
　　 この関数を呼べば，サーバと繋がるよ，という風にメッセージ
　　 を書いてくれているため，こうした文字列が出るわけである．
     今まで岡田先生のソフトウェア第３で，hanoi.lとかをロードすると，
　　 勝手に，(show-hanoi)とかいうメッセージが出てきたのと同じである．
     なお，今回はvision-server(画像処理サーバ)を立ち上げていないので，
     (connect-vision-server)は用いない．

   irteusgl $ (connect-robot-server)
     とすると，実際にロボットサーバと繋がり，やりとりのためのインスタンス
     が *rs* にバインドされる．
     上の関数を実行して，Connected server: Port 5000
     とか出れば，接続に成功である．成功しない(cannnot connectと出る）
　　 ときは，サーバが上がっているかを確認しよう．
　　 以降は，この *rs* に対して，メソッド（メッセージ）を送ることで
　　 サーバに命令を送ることができる．
　　 なお，詳しい使い方については，robot-client.lの先頭の長いコメントに
　　 載っている（付録にも）のでそれを参照して欲しい．
  \end{verbatim}
 \vspace{-10mm}
\end{itembox}
%$
{\bf この作業は\figref{enshu-system-c5}に相当する}．
赤色は既に立ち上がっているserver部，青色がEusLispで実行されているクライアント部分になる．
なお，チェックポイント５の段階では，robot-client.lに記述された
(connect-robot-server)という関数を呼び出し，shlinux側のserverのソケットと通信ストリーム
を確保した，という部分までである．
%%

次に，簡単に台車や腕を動かすための実行例をチェックポイント6に示したので試してみよ．
{\bf この作業もチェックポイント５と同様，システム図上では\figref{enshu-system-c5}に相当する}．
ただし，チェックポイント5の(connect-robot-server)で繋いだソケットの通信ストリームに対して，
対話的にコマンドを送受信することで（C言語でのsendto()/recvfrom()のようなことをしている)，
台車に動かしたりセンサデータを取得し，実際にサーバクライアントによるロボット行動を制御している
例がチェックポイント６の作業となる.
\begin{itembox}[|]{{\bf チェックポイント6: EusLispのクライアントから台車を対話的に動かす}}
 \vspace{-2mm}
  \begin{verbatim}
   irteusgl $ (send *rs* :bumper-vector)
     とすると，現在のバンパの状態，６つの要素のベクトルが返ってくる．
     押していると1，押されていないと0が返ってくる．確認せよ．
   
     コマンドを実行したときに押していないとわからないので確認が難しい
　　 かもしれない．この場合
   irteusgl $ (do-until-key (print (send *rs* :bumper-vector)))
     と打つと，Enterを押すまでbumper-vectorの情報が表示されるので確認しやすい．
     do-until-keyはEnterを押すまでループする，printは値を表示
　 irteusgl $ (send *rs* :daisya-velocity-vector #f(0 0 300))
     とすると，台車が回転し出すはずである．
　　 台車を浮かして試してみよう．止めるためには，同じコマンドで目標値を
　　 #f(0 0 0)として与えればよい．
　　　それぞれ第一要素はｘ方向の速度，ｙ方向の速度，回転速度[deg/sec]

     実際には台車の速度制御だけだと不便である．そこで，自身の位置情報を車輪
　　 エンコーダ情報を積分することで推定することで位置制御を行う制御ループ
　　 がshlinux上のrobot-serverの台車コントロールプログラムには用意してある
　　 のでこれを利用していみよう．
     回転及び直進はある程度使用に耐えられる状態であるはずである．
　　　全方位台車の車輪方向の問題で左右方向はまともに動かないかもしれないが，
　　 台車の位置制御を行うには，以下のようにすればいい
　 irteusgl $ (send *rs* :daisya-controlmode 2)
     台車の制御モードを変更する．2が位置制御，それ以外が速度制御である．
　　　デフォルトは速度制御になっている．
　 irteusgl $ (send *rs* :daisya-position-vector #f(100 0 0) 3000)
     とすると，台車が100[mm]程直進して止まるはずである．
　　　順に，ｘ方向の相対位置[mm]，ｙ方向の相対位置[mm]，鉛直方向回転角度[deg]，
     遷移時間[mm]となっている．

　 irteusgl $ (send *rs* :arm-poweron-vector #f(0 0 0 0 1))
     とすると，腕のサーボ（各軸）の制御スイッチを入れることができる．
     1にすると制御ＯＮ，0で制御ＯＦＦのはずである．
　　 これを送ると，末端のハンド部が制御が入るはずである．
   irteusgl $ (send *rs* :arm-angle-vector #f(0 0 0 0 30) 1000)
     とすると，腕のサーボ各軸の目標角度を送ることができる．
　　 1000は目標遷移時間[msec]であり，目標までの到達時間を調整可能
    この例だと，1秒で，5番目関節(hand)を30[deg]まで動かす，はずである．
   irteusgl $ (send *rs* :arm-poweron-vector #f(0 0 0 0 0))
     としておけば，サーボの制御がオフになる．
　　　制御を入れっぱなしにしておくのは危険なので，動かすことを試した後は
　　　必ずこのメソッドを呼んで，制御を切っておこう．
  \end{verbatim}
 \vspace{-10mm}
\end{itembox}
%$
さて，これでeuslispの{\bf シェルから対話的にサーバと繋ぎ，コマンドを送って
ロボットを動かす方法}がわかったかと思う．

では次に，この知識を元に，ある入力が来たときに，ある行動をするような
シンプルな反応系のロボット行動プログラムを記述するにはどうすればいいだろうか．
それを記述したものが，同じディレクトリにあるsample.lなので見てみて欲しい．
動かし方はとても簡単で，以下のようにすればいい．emacsのシェルでirteusglが走った
状態にしておいて，
\begin{itembox}[|]{{\bf チェックポイント7: EusLispで記述した反応行動クライアントプログラムの実行}}
 \vspace{-2mm}
  \begin{verbatim}
   irteusgl $ (load "sample.l")
    すると，
     (connect-robot-server)
     (connect-vision-server)
     (demo)
    というメッセージが返ってくる．
　　ここで，上の二つは，sample.lの中で(load "robot-client.l")
    として，さっきまで説明したサーバと繋ぐための関数定義ファイルを
　　ロードすると自動で出てくるメッセージなので気にしない．
 
    ここでは，(demo)と打って実行すればいい．
  irteusgl $ (demo)
    何もしていない場合は直進しようロボットはするはず．
　　各バンパを押すとその反対方向に台車がちょっと動くはず．
  \end{verbatim}
 \vspace{-10mm}
\end{itembox}
sample.lの中身は以下のような構成になっている．
\begin{screen}
\begin{enumerate}{\itemsep=-4pt
\item {\bf サーバ接続関数定義ファイルrobot-client.lのロード}
\item {\bf demo関数の定義}
  \begin{enumerate}{\itemsep=-4pt
    \item サーバとの接続処理\\
      whenを使って*rs*がなければ，サーバと接続するように書いてある．
    \item 台車の制御モードを位置制御に変更\\
    \item ループ処理 do-until-key関数を使ってキー入力あるまでループ処理\\
      1. *rs*に対してbumper-vectorメソッドを送り，バンパ状態を取得\\
      2. バンパの押されている場所に応じて，台車移動量を決定\\
      3. *rs*に対して，daisya-position-vectorメソッドを使って，移動量を送る\\
      4. 遷移時間の間待ち，ループの1に戻る
    \item 台車の制御モードを速度制御に変更\\
  }\end{enumerate}
}\end{enumerate}
\end{screen}
\figref{sample-l}のようにとても短い(コメント入りで100行以内)ので，嫌がらずに読んでみて欲しい．
また，{\bf この関数実行はシステム図から見ると，\figref{enshu-system-c7}}のようになる.
ほぼ\figref{enshu-system-c5}と同様だが，対話的に動かしていくのではなく，
sample.lに記述された行動関数(demo)を実行しているという緑枠の部分が多少異なる.
\begin{figure}[!th]
  \begin{center}
    \pastefig{fig/sample-l.jpg}{width=0.8\hsize}
    \caption{sample.lの様子}
    \figlabel{sample-l}
    \vspace{-5mm}
  \end{center}
\end{figure}
\begin{figure}[!th]
  \begin{center}
    \pastefig{fig/enshu-system-c7.jpg}{width=0.8\hsize}
    \caption{演習のシステム全体概要図におけるEusLispでのclientによる反応行動}
    \figlabel{enshu-system-c7}
    \vspace{-5mm}
  \end{center}
\end{figure}
%%
%%
\subsection{各ディレクトリの説明：eus}
さて，最後にEusLispで構築したシミュレーション環境と実機環境の関係について説明しよう．
このディレクトリは，ソフトウェア第三でも使ったことがあるはずである．
簡単にプログラムの概要を説明すると，
{\bf ls}で覗いてみると，以下のようなファイルがあるはずである．
\begin{screen}
  \vspace{-2mm}  
  \begin{verbatim}
 eus
  <探索アルゴリズムプログラム>
  |-- gsearch.l : 探索
  |-- hsearch.l:  探索
  |-- psolve.l :  探索
  |-- sets.l :    集合の扱い
  |-- hanoi.l :   ハノイの塔を解くサンプル
  |-- qlearn.l :  強化学習
  |-- subsumption.l : サブサンプション
  |
  <演習の移動台車シミュレーション環境構築に必要なプログラム>
  |-- daisya.l : ロボット台車モデル  
  |-- robot-server-simulator.l : シミュレーションプログラム
  |-- virtual_interpolator.l : 台車のモータ指令値補間
  |-- irteusext.l : その他，必要な関数群定義
  |-- maze.l : 迷路モデルの構築
  |
  <移動台車のサンプルプログラム>
  |-- sample-robot-server.l :　シミュレーションサンプルプログラム
  |-- daisya-hanoi.l :  ハノイの塔のサンプルプログラム
  |-- daisya-qlearn.l : 強化学習で迷路を解くサンプルプログラム
  |-- daisya-maze.l :   探索で迷路を解くサンプルプログラム
  |-- daisya-ik.l :     台車の逆運動学を解くサンプルプログラム
  |-- daisya-subsamption.l :     台車を用いたサブサンプション行動プログラム
  |-- sample-sim.l : シミュレーションに繋ぐためのシンプルな行動サンプル
  |-- sample-sim-real.l : シミュレーションと実機への接続を切り替え両方で同じコードが動くシンプルな行動サンプル
  \end{verbatim}
  \vspace{-10mm}
\end{screen}
詳しい使い方は，ソフトウェア第三の方の資料に載っているので省くが，シミュレーション
環境の使い方を復習しよう．1)シミュレータの起動，2)シミュレータとの接続，
の２ステップが必要になる．
まず，シミュレータの起動だが，
\begin{itembox}[|]{{\bf チェックポイント8:EusLispでのシミュレーション環境の起動}}
  \vspace{-2mm}  
  \begin{verbatim}
    まずロボットサーバシミュレータ用のirteusglを立ち上げ，
 irteusgl $ (cd "~/prog/jsk-enshu/robot-programming/eus")
 irteusgl $ (load "sample-robot-server.l")
 　して必要な関数をロードした後，
 irteusgl $ (init-server)
  として，シミュレーション環境を起動する．
　このとき，(init-server 'simple-maze)とするとシンプルな迷路が
  (init-server 'maze)とすると25マスの迷路が出現する．
 とすればよい．
  \end{verbatim}
  \vspace{-10mm}
\end{itembox}
%$
を実行すればよい.
台車が何らかの環境にいるビューアが出てくるはずだ.
{\bf このシミュレータは，EusLispで記述されているが，shlinuxで動いている
Cで記述したserverプログラムと同じようにソケット通信(port 5000番)で，
クライアントからの接続を待ち受けている\footnote{
詳しくはrobot-server-simulator.lに書いてある．
}サーバプログラムである．}

次にこのシミュレータに対して行動プログラムを接続し，動かすことになるわけだが，
ソフトウェア第三で説明した手順は，本資料の付録に示したように，再びsample-robot-server.l
を別irteusglで立ち上げ，(demo)関数を呼び出す，というものであったと思う.
しかし，sample-robot-server.lは，シミュレータ環境の用意(起動)と，
シミュレータ環境への接続・行動指令を行うプログラムコードが一つのファイルに纏まっている
ため，混乱してしまった人もいるかもしれない．

そこで，{\bf シミュレータ環境の起動については引き続き，sample-robot-server.lを用いるとして，
シミュレータ環境への接続・行動指令を行うために最低限必要な部分を切り分けたプログラムを
robot-programming/eus/sample-sim.l
として用意した．}
simulatorが既に立ち上げっている状態で，シミュレータとは別のirteusglを別途起動し，
その上で以下を試してみよう．
\begin{itembox}[|]{{\bf チェックポイント9: EusLisp行動クライアントからEusLispシミュレータ台車を動作}}
  \vspace{-2mm}  
  \begin{verbatim}
    simulatorとは別の行動プログラム用のirteusglを立ち上げること
 irteusgl $ (load "sample-sim.l")
   としてロードする．
 irteusgl $ (demo)
   と打つと，シミュレータとの接続，行動ループが回りシミュレータのロボットが動き出す．
　 Enterを押すと終了する．
  \end{verbatim}
  \vspace{-10mm}
\end{itembox}
\begin{figure}[!th]
  \begin{center}
    \pastefig{fig/enshu-system-c8.jpg}{width=0.8\hsize}
    \caption{演習のシステム全体概要図におけるEusLispでのシミュレータ環境}
    \figlabel{enshu-system-c8}
    \vspace{-5mm}
  \end{center}
\end{figure}
さて，{\bf チェックポイント8，9の作業をシステム図上で表すと\figref{enshu-system-c8}}のようになる．
ここで大事なのは，シミュレータ環境なので今までと違い，台車shlinux側では何も動かさずに
{\bf 完全にノートPC上Linuxでシステムが完結}している点，シミュレータと行動プログラムの間の
通信は，今まで説明してきたshlinuxのserverプログラムとlinux上のclientプログラムの通信
と{\bf 同様にソケット通信を用いている(図中の青丸)}点である．ただし，異なるTCP/IPネットワーク
間通信をする必要がないので，アドレスを127.0.0.1(自分自身)に指定して，クライアントが
ソケット通信を開いている点が実機を用いた場合と異なっている．

つまり，{\bf 行動クライアントプログラムにとってみると，シミュレータでも実機でも
ソケット通信の繋ぎ先が，シミュレータ(127.0.0.1)になるか，
実機shlinuxのserver(192.168.x.y)になるか，という違いしかない}ように作られているのが
味噌である．

そうした点を踏まえてsample-sim.lの中身を覗いてみると，
実は\subsecref{client}のeus-clientの節で説明した
実機に対する行動プログラムの例であるrobot-programming/client/eus-client/sample.l
とほぼ同じ構成になっている．二つを比べてみたのが，\figref{sample-comp}である．
\begin{figure}[!th]
  \begin{center}
    \pastefig{fig/sample-comp.jpg}{width=0.8\hsize}
    \caption{シミュレータと実機それぞれに対する行動クライアントプログラムの比較}
    \figlabel{sample-comp}
    \vspace{-5mm}
  \end{center}
\end{figure}
ほぼ同じであることがわかるだろう．実際に自分でもエディタで開いて違いを
確認してみて欲しい．
二つのプログラムの違いは，
\begin{screen}
\begin{itemize}{\itemsep=-3pt
\item {\bf 最初の行でロードする関数が違う}\\
  robot-server-simulator.lかrobot-client.lか
\item {\bf 実機との接続，シミュレータとの接続に用いる関数名が違う}\\
  connect-robotsim-serverかconnect-robot-serverか
\item {\bf 実機，シミュレータのバインド変数名が違う}\\
  *rs-sim*か*rs*か
}\end{itemize}
\end{screen}
だけであり，行動プログラムの記述は全く同じになっていることに注意しよう．

ここまでほぼ同じだと，一つのプログラムを用意して，関数に渡す引数をかえることで，
実機に繋ぐかシミュレータに繋ぐかを試したくなってくるだろう．
そのプログラムが，{\bf simple-sim-real.l}である．
{\bf 自分のノートPCにsimulatorが走っている状態，かつ自分の班の台車で
robot-serverが立ち上がっている状態，すなわちシミュレータ側も実機側も
サーバサイドが立ち上がっている状態}になっていれば，
以下のように一つのプログラムで記述された行動プログラムをシミュレータ，
実機両方で透過的に用いることができる．
試してみよう．
\begin{itembox}[|]{{\bf チェックポイント10:シミュレータ実機両接続可能な行動クライアントの書き方}}
  \vspace{-2mm}  
  \begin{verbatim}
    ロボットサーバとは別の行動プログラム用のirteusglを立ち上げること
 irteusgl $ (load "sample-sim-real.l")
   としてロードする．
 irteusgl $ (demo)
   と打つと，シミュレータと接続，行動ループが回りシミュレータ上ロボットが動く．
   Enterを押すと終了する．
 irteusgl $ (demo :real t)
   と打つと，実機と接続，行動ループが回り実機ロボットが動き出す．
　 Enterを押すと終了する．
  \end{verbatim}
  \vspace{-10mm}
\end{itembox}
%$
どちらも同じ挙動をするはずである\footnote{
  実際は実機の制御に問題があり，きちんとこちらの思ったとおり動かない
  わけではあるが
}．
このようにしておけば，{\bf シミュレータ側で行動プログラムをデバッグし，
うまくできてきたら実機に送ってみる，ということができて開発効率が
上がるので嬉しいね，ソフトウェア第三楽しいね}，
という遥かなる理想を何となく理解してもらえれば幸いである
\footnote{
無論，シミュレータと実機がなるべく同じ挙動をするように両方のシステム
(ソフトウェア，ハードウェア両面)が洗練されている，ことが前提条件である．
現実は厳しいもので，演習環境にはまだまだ改善の余地やバグが多いのだが，
日々精進して開発を進めているので生暖かい目で見守って欲しい}．

最後に，このチェックポイント10の作業をシステム図から確認したものが\figref{enshu-system-c10}
である．青丸の部分がEusLispの行動クライアントで，ソケット通信を繋ぐ先をシミュレータ側
(127.0.0.1)か，実機サーバ側(192.168.x.y)に切り替えるだけで，同じ行動プログラムが
動いている，というのがポイントとなっている．
\begin{figure}[!th]
  \begin{center}
    \pastefig{fig/enshu-system-c10.jpg}{width=\hsize}
    \caption{シミュレータと実機両方へ対応可能な行動クライアントプログラムの位置づけ}
    \figlabel{enshu-system-c10}
    \vspace{-5mm}
  \end{center}
\end{figure}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\clearpage
\section{本日の演習課題}

各班で合計１００ポイント以上を獲得すること．

班のメンバーで相談し役割分担や協力しながら効率よくポイントを稼いで欲し
い．ただし，０ポイントのメンバーは認めない．

\seclabel{kadai}
\subsection{課題0: 10 Point}

分からないこと，追加してほしい機能，見つけたバグ，作ってみたパッチ
などをjsk-enshuのチケットシステム（
http://sourceforge.net/apps/trac/jsk-enshu/
）に登録するか，

https://lists.sourceforge.net/lists/listinfo/jsk-enshu-users
でメーリングリストに登録して投稿してみよう\footnote{
恥ずかしがらずに，何でも聞いてみる癖をつけることが，
チケットシステムやメーリングリストを活用することが，
今後研究室にはいって研究をすすめていく上でとても重要な
能力になってくるので，今のうちから習慣をつけておくのがよい．
}．

分からないことがたくさんある人は，何度も投稿すればよい．
その回数分だけポイントを進呈する．

\subsection{課題1: 30 Point}
それぞれチェックポイント１〜１０で行ったプログラム実行が\figref{enshu-system}のどの部分
で行われたかがすぐに説明できるようにせよ．
各自ある程度説明できる自信がついたらTAを呼ぼう．
TAに自分がシステムを把握していることを納得させればOKである．

TAがするであろう質問は例えば以下のようなものであろう．資料を探せば答えはどこかに
乗っているはずである．
\begin{itemize}
\item svn updateはshlinuxでやってる？それともlinuxでやってる？
\item minicomとsshの違いは？
\item serverは同時に何個立ち上げられる？
\item ためしにチェックポイント10をやってみてよ
\item サーバとクライアントは何通信をしてる？
\item ロボット制御でやったstandaloneなプログラムと今回のserverプログラムの違いは何？
\item どうしてクロスコンパイルしてるの？っていうかクロスコンパイルって何？
\item シミュレータと実機を同じプログラムで動かせると何が嬉しいの？
\item 何でサーバとクライアントにわざわざ分けてロボットを動かすの？
\item robot-viewerとsample.lの(demo)は同時に動く？そしてそれは何故？
\item この演習のチェックポイントでやったclientなプログラムは例えばどれとどれ？
\end{itemize}
実際にどのような質問をするかは各TAの自由裁量に任せている．

班のメンバー全員がいずれかの質問に答えること．

%%
%% \subsection{課題2: }
%% グループ全員が，以下の手順を{\bf 資料を見ずに}行えることをTAの前で実演せよ．
%% どうしても記憶できない，という場合でも，TAが頭文字のヒントを与えるので，
%% それを元に頑張って実行してみよ．
%% 覚えるコマンドが多すぎて無理という場合は，演習中にこちらで覚えてもらう
%% コマンドを適宜指定（重要なのは５つくらい）するので，それを覚えておくこと．
%% \begin{enumerate}{\itemsep=-4pt
%% \item {\bf 台車のshlinuxの起動（これは時間がかかるので代表者一人で良い）}
%% \item {\bf サーバ（ロボット制御用，ビジョン用）の起動}
%% \item {\bf クライアントの起動（Cで書かれたsensorビューア)}
%% \item {\bf euslispの起動}
%% \item {\bf euslispから，ＴＡの指示する指令を実行（TAのアドリブ)}\\
%%   車輪の一つを位置制御で動かせ，速度制御で動かせ，
%%   腕のサーボの指定した軸を指定した時間で動かしてみよ
%% \item euslispで書いた，簡単なプログラムを実行してみよ．等
%% }\end{enumerate}
%% なお，ここでは，起動するプログラム名やコマンド名について，資料中に
%% （主に，\subsecref{server}，\subsecref{client}）に書いてあることを読めば，
%% わかるはずなので，{\bf あえて記述していない}．皆頑張って欲しい．
%% さっぱり資料の意味がわからない人は，TAを読んで講習会を開いてもらうとよい．
%%
\subsection{課題2: 30 Point}
robot-programming/client/eus-client
の下のsample.lを改良し，バンパ以外のセンサ(PSDセンサ)や車輪以外の
モータ(腕サーボ)を使った反応プログラムを記述してみよ．
なお，どのようなメソッドでEusLispから台車の情報が取れるかは付録に書いてある．

{\bf sample.lを消すのではなく，cp sample.l sample-kadai3.lのようにしてリネームして
開発を行うと良い．}
そうすれば，何か動かなくなった場合でも，元のプログラムに戻れるので
プログラムの開発が円滑に進む．プログラム開発の地味だが重要なテクニックである．

%%
\subsection{課題3: 30 Point}
robot-programming/eusの下のsample-sim-real.lを改良し，
実機・シミュレータ両方で動く行動プログラムを記述してみよ．

課題3で行った部分がシミュレータでも動くようにしても良いし，
robot-programming/eus/sample-robot-server.lの中にある
demo0，demo1，demo2，demo3，demo4が実機でも動くように書いてみても
良い．
%%
\subsection{アドバンスド課題：50 Point}
robot-programming/client/eus-client
の下のsample.lを改良し，迷路を脱出するプログラムを書いてみよ．
迷路はTAに言ってもらえば，作ってもらえる．
バンパにぶつかった際の挙動を少し変える戦略や，
センサを使わずに台車の位置制御の精度を上げることで
脱出するといった戦略を試してみると面白い．
ロボット制御のときに迷路に挑戦した人は同じような戦略をEusLispで記述
してみるのもいいかもしれない．

なお，移動台車演習が始まって5年目くらいであるが，未だセンサを
用いずに{\bf 壁に触れずに}迷路脱出した成功例\footnote{
  デッドレコニングと呼ぶ
}はないので，興味があれば是非チャレンジしてみて欲しい(100Point)．
大村先生の演習で台車をまっすぐ走らせるようにチューニングした成果を
是非見せてみよう．
%%
\clearpage
付録
\appendix
\section{shlinuxへのloginが早くなるかもしれない変更}
ログイン時に不必要なIPを探さないように設定を書き換えてやる作業をすることで，
sshのログインが早くなる可能性がある．
演習では，{\bf sshのログインやscpを多用するため，この作業がないと作業効率が異常に低下する}ので
やってみて損はないかもしれない．
\begin{screen}
 \vspace{-2mm}
  \begin{verbatim}
   Ubuntuの端末で
    $ sudo su
     rootになる．passwordは　u-tokyo
    # cd /etc
    # cp nsswitch.conf nsswitch.conf.org
     バックアップをとっておく
    # emacs nsswitch.conf &
     設定ファイルnsswitch.confをemacs（viでもよい)で開く
     hosts:で始まる行があるが，
　　 hosts: files dns
     だけにしてsaveする．
　　 元は，files mdns4_minimal [NOTFOUND=return] dns mdns4　とあるはずである
    # /etc/init.d/networking restart
     をして，ネットワークを再起動する
    # exit
     でroot権限からログアウトする．
  \end{verbatim}
  \vspace{-10mm}
\end{screen}
%$
この作業をしておけば，ssh root@192.168.x.yをしたときに待たされる時間が減るはずである．
%%
\section{robot-client.lのメソッドの説明}
  robot-programming/client/eus-client/robot-client.lについてrobot-serverに関するものについて
　説明する．vision-serverに関するものも含まれているが，それについては次回資料において説明を行う．
  ここでは，SH台車で上がっているサーバから情報を取得したり命令を送信するための
  クラスファイルが定義されている．irteusglを起動した状態で，
  （ただし，robot-serverが台車であがっているとして)
\begin{screen}
  \begin{verbatim}
   (connect-robot-server :host host)
     ただし、hostには "192.168.x.y" のような台車IPを""でくくったものをいれること
     robot-serverアクセスへのインスタンス *rs* ができる．
   (setq hoge (connect-robot-server)) 
     のように好きな変数にバインドしても良い．
  \end{verbatim}
\end{screen}
  サーバに命令を送るには，*rs*に対してメソッドを送ればよい．
　以下に簡単に実装されているメソッド例を紹介する．\\
{\bf [robot-serverへの指令]}
\begin{itemize}{\itemsep=-4pt
  \item {\bf 台車への指令}
    \begin{itemize}{\itemsep=-4pt
	\item 車輪制御モードの変更 {\bf wheel-controlmode-vector}\\
	  PWM制御:0, 速度制御:1, 長さ制御: 2, 制御OFF:-1\\
	  それぞれの車輪の制御モードを変更する. 普通は速度制御しか使わないかな\\
	  (send *rs* :wheel-controlmode-vector \verb+#+f(1 1 1))
	\item 車輪目標角度の変更 {\bf wheel-angle-vector}\\
	  目標角度を送る：車輪が角度制御の場合、指定した量だけ車輪が回転する\\
	  (send *rs* :wheel-angle-vector \verb+#+f(100 0 0))
	\item 車輪目標速度の変更 {\bf wheel-velocity-vector}\\
	  目標速度を送る：車輪が速度制御の場合、指定した速度で車輪が回転しつづける\\
	  (send *rs* :wheel-velocity-vector \verb+#+f(200 200 0))
	\item 初期状態(servo-off状態, encoder=0, 各種目標値0)に戻す {\bf wheel-reset}
	  暴走したときなど、このコマンドを送ればストップする.
	  プログラムが終ったら、とりあえずこのコマンドを送っておけば安心．\\
	  (send *rs* :wheel-reset)
	\item 台車に目標xy速度、目標角速度[deg]/secを与える {\bf daisya-velocity-vector}\\
	  与えるvectorの各要素が順に、目標x速度、目標y速度、目標角速度 となる．
	  車輪を制御するのは面倒なので、実際はこの台車制御コマンドを使うことがほとんどだろう．\\
	  (send *rs* :daisya-velocity-vector \verb+#+f(200 0 200))
	\item 台車の制御モードを変更する {\bf daisya-controlmode}\\
          2が位置制御，2以外が速度制御となる．デフォルトでは速度制御となる．\\
	  (send *rs* :daisya-controlmode 2)
	\item 台車に目標xy位置[mm]、目標角速[deg]、遷移時間[msec]を与える {\bf daisya-position-vector}\\
          各々現在の台車位置からの相対位置座標となる．
	  台車の速度制御を用いるよりも位置制御を用いた方が，迷路を脱出するときなどは
          有効であるかもしれないので，うまく動きそうなら使ってみて欲しい．\\
	  (send *rs* :daisya-position-vector \verb+#+f(200 0 200) 3000)
    }\end{itemize}
  \item {\bf 腕への指令}
    \begin{itemize}{\itemsep=-4pt
	\item 腕のservoの制御のONOFF {\bf arm-poweron-vector}\\
	  1:ON, 0:OFFな状態で、５個のservoそれぞれの制御をONOFFできる．
	  プログラムが終了したら、これを呼んでとりあえず全てOFFにしておくのが安心\\
	  (send *rs* :arm-poweron-vector \verb+#+f(0 0 0 0 0))
	\item 腕servoの補間方式を変更する {\bf arm-interpolation-method}\\
	  線形補間 1, やくど最小補間 2, となっているので好きな方に切替えてください．
	  defaultは線形補間\\
	  (send *rs* :arm-interpolation-method 1)
	\item 腕の目標角度指令を送る {\bf arm-angle-vector}\\
	  第一引数はvectorで５個それぞれのservoの目標角度[deg]を表す．
	  第二引数は遷移時間で[msec]で与える．\\
	  (send *rs* :arm-angle-vector \verb+#+f(20 10 20 0 0) 1000)
    }\end{itemize}
  \item {\bf センサ情報の取得}
    \begin{itemize}{\itemsep=-4pt
      \item bumperのONOFF状況の取得 {\bf bumper-vector}\\
	6つあるbumperのONOFF状態がかえって来る。
	1だとONで、0だとOFFとなる.\\
	(send *rs* :bumper-vector)
      \item 距離センサ値の取得 {\bf psd-vector}
	3つあるpsdセンサの値がかえってくる．
	ただし、psdセンサはおそらく一つは台車の仕様上読めないが気にしない.\\
	(send *rs* :psd-vector)
    }\end{itemize}
}\end{itemize}

\section{sample-robot-server.lによる行動プログラムの実行}
既にsample-robot-server.lをloadしてシミュレーション環境を起動済みのirteusgl環境
プロセスが走っているとする.
以下の行動プログラムは，このirteusglとは異なる新たな{\bf シミュレータとは別のirteusglを立ち上げて}
実行すること．
\begin{screen}
  \vspace{-2mm}  
  \begin{verbatim}
    ロボットサーバとは別の行動プログラム用のirteusglを立ち上げ
 irteusgl $ (load "sample-robot-server.l")
   として必要な関数をロードする．ロードするファイルはシミュレータ
　 の場合と同じである．
 irteusgl $ (connect-robotsim-server)
   と打つと，シミュレータと繋がり，シミュレータとやり取りをする*rs-sim*
   ができる．この状態で，
 irteusgl $ (demo0)
   とすると，シンボル空間で解いた迷路情報を元に，対応する座標へロボットを動かす
 　指令を送っていく．なお，人によってはうまく解けずに壁に激突して止まるかもしれ　
　 ないが，これはシミュレータ環境時間がPC性能によって変動するため，プログラムの
 　待ち時間がずれてしまうためである．
 irteusgl $ (demo1)
　 とすると，壁にぶつかったらバックするというプログラムが走る．
　 ただし，中身を見るとわかるがバンパセンサが正確に前2つ，後ろ２つが反応しないと
　 行動を修正しないように書かれているため，もしかすると壁にぶつかったまま動かない
　 こともあるかもしれない．
 irteusgl $ (demo2)
   demo1をサブサンプションで記述してみた例である．
 irteusgl $ (demo3)
   画像（赤色重心画像）と距離センサ，バンパセンサの入力によって行動を変える例が動く．
　 このプログラムは，迷路で動かすよりも，simple-mazeで動かした方がうまくいく．
　 この場合，後述のシミュレーション環境の再起動の手順を行う必要がある．
 irteusgl $ (demo4)
   サブサンプションの例である．これは迷路maze環境で実行するのが良い．
  \end{verbatim}
  \vspace{-10mm}
\end{screen}
%$

%% \section{サンプルプログラム}
%% daisya-sample.tgzに入っているプログラムソースを載せておきます．
%% \subsection{最低限理解して欲しいサンプル simple-daisya-move.l}
%%  {\scriptsize
%%  \listinginput[1]{1}{daisya-sample/simple-daisya-move.l}
%% \subsection{ちょっと理解して欲しいサンプル daisya-hanoi.l}
%%  {\scriptsize
%%  \listinginput[1]{1}{daisya-sample/daisya-hanoi.l}
%% %%
%% \subsection{bodyの作り方の参考かもしれないサンプル maze.l}
%% どうせ12ページになってしまうと，16ページまで使わないと勿体ないから載せておきます
%%  {\scriptsize
%%  \listinginput[1]{1}{daisya-sample/maze.l}
\end{document}
